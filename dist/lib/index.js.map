{"version":3,"sources":["webpack://deltav-network-data/webpack/universalModuleDefinition","webpack://deltav-network-data/webpack/bootstrap","webpack://deltav-network-data/./lib/util/make-list.ts","webpack://deltav-network-data/./lib/util/map-of-maps.ts","webpack://deltav-network-data/./lib/types.ts","webpack://deltav-network-data/./lib/data/remove-edge.ts","webpack://deltav-network-data/./lib/util/index.ts","webpack://deltav-network-data/./lib/data/add-edge.ts","webpack://deltav-network-data/./lib/util/access.ts","webpack://deltav-network-data/./lib/data/make-network.ts","webpack://deltav-network-data/./lib/calculate/get-edge.ts","webpack://deltav-network-data/./lib/calculate/index.ts","webpack://deltav-network-data/./lib/data/clone-edge.ts","webpack://deltav-network-data/./lib/data/clone-node.ts","webpack://deltav-network-data/./lib/selection/index.ts","webpack://deltav-network-data/./lib/data/combine-shared-edges.ts","webpack://deltav-network-data/./node_modules/simple-data-provider/dist/index.js","webpack://deltav-network-data/./lib/util/make-error.ts","webpack://deltav-network-data/./lib/util/random.ts","webpack://deltav-network-data/./lib/data/add-node.ts","webpack://deltav-network-data/./lib/data/remove-node.ts","webpack://deltav-network-data/./lib/selection/neighbors.ts","webpack://deltav-network-data/./lib/selection/shared-connection.ts","webpack://deltav-network-data/./lib/selection/travel-path.ts","webpack://deltav-network-data/./lib/calculate/max-weight.ts","webpack://deltav-network-data/./lib/calculate/min-weight.ts","webpack://deltav-network-data/./lib/calculate/weight-at-index.ts","webpack://deltav-network-data/./lib/data/index.ts","webpack://deltav-network-data/./lib/data/empty-network.ts","webpack://deltav-network-data/./lib/index.ts","webpack://deltav-network-data/./lib/selection/all-edges.ts","webpack://deltav-network-data/./lib/util/shallow-list-compare.ts","webpack://deltav-network-data/./lib/util/random-network.ts","webpack://deltav-network-data/./node_modules/random-seed/index.js","webpack://deltav-network-data/./node_modules/json-stringify-safe/stringify.js","webpack://deltav-network-data/./lib/util/network-data-manager.ts","webpack://deltav-network-data/./lib/selection/no-connections.ts","webpack://deltav-network-data/./lib/selection/ripple-select.ts","webpack://deltav-network-data/./lib/selection/travel-collision-path.ts","webpack://deltav-network-data/./lib/calculate/compare.ts","webpack://deltav-network-data/./lib/calculate/has-circular-edge.ts","webpack://deltav-network-data/./lib/calculate/has-node.ts","webpack://deltav-network-data/./lib/calculate/node-weight-range.ts","webpack://deltav-network-data/./lib/data/clone-network.ts","webpack://deltav-network-data/./lib/data/convert-network.ts","webpack://deltav-network-data/./lib/data/network-set-operations.ts","webpack://deltav-network-data/./lib/data/remove-circular-edges.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","self","e","default","this","__generator","u","label","sent","trys","ops","next","a","throw","return","iterator","TypeError","done","pop","length","push","__await","v","__asyncValues","asyncIterator","Promise","resolve","then","__asyncGenerator","apply","f","shift","__values","Array","isArray","ProviderType","LIST","constructor","Set","Map","SET","ITERATOR","ITERATOR_ASYNC","OBJECT","METHOD","UNKNOWN","type","values","arguments","y","b","h","T","E","S","O","_","w","P","N","R","METHOD_SYNC","METHOD_ASYNC","GENERATOR","GENERATOR_ASYNC","error","isIterable","isAsyncIterable","console","warn","PRIMITIVE","__awaiter","retrieve","stringify","Mash","data","toString","charCodeAt","uheprng","seed","j","k","mash","Math","random","rawprng","range","floor","string","count","String","fromCharCode","hash","args","slice","cleanString","inStr","replace","hashString","initState","addEntropy","Date","getTime","join","Number","MAX_VALUE","floatBetween","min","max","intBetween","serializer","replacer","cycleReplacer","stack","keys","indexOf","thisPos","splice","Infinity","obj","spaces","JSON","getSerialize","NetworkDataManager","RippleSelect"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"deltav-network-data\"] = factory();\n\telse\n\t\troot[\"deltav-network-data\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 27);\n","/**\n * Makes a simpler way to copy a single or list of items to a new array.\n * This can also flatten a list of lists to a list.\n */\nexport function makeList<T>(items: T | T[] | T[][] | Set<T>): T[] {\n  if (items instanceof Set) {\n    const list: T[] = [];\n    items.forEach((v) => list.push(v));\n    return list;\n  }\n\n  return Array.isArray(items)\n    ? Array.isArray(items[0])\n      ? (items as T[][]).reduce((p, n) => p.concat(n), [])\n      : (items as T[]).slice(0)\n    : [items];\n}\n","/**\n * This is a helper to add a value to a map of maps.\n */\nexport function addToMapOfMaps<T, U, V>(\n  map: Map<T, Map<U, V>>,\n  firstKey: T,\n  secondKey: U,\n  value: V\n) {\n  let nextMap = map.get(firstKey);\n\n  if (!nextMap) {\n    nextMap = new Map();\n    map.set(firstKey, nextMap);\n  }\n\n  nextMap.set(secondKey, value);\n}\n\n/**\n * This is a helper to remove a value from a map of maps\n */\nexport function removeFromMapOfMaps<T, U, V>(\n  map: Map<T, Map<U, V>>,\n  firstKey: T,\n  secondKey: U\n) {\n  const nextMap = map.get(firstKey);\n  if (!nextMap) return false;\n  return nextMap.delete(secondKey);\n}\n\n/**\n * This is a helper to get a value from a map of maps\n */\nexport function getFromMapOfMaps<T, U, V>(\n  map: Map<T, Map<U, V>>,\n  firstKey: T,\n  secondKey: U\n): V | undefined {\n  const nextMap = map.get(firstKey);\n  if (!nextMap) return;\n  return nextMap.get(secondKey);\n}\n","/**\n * This depicts all values that evaluate to false.\n */\nexport type Falsy = false | 0 | \"\" | null | undefined;\n\n/**\n * This ensures a value is defined (does not use falsey so passes 0's and empty\n * strings)\n */\nexport function isDefined<T>(val?: T | null): val is T {\n  return !(val === void 0 || val === null);\n}\n\n/**\n * A numerical expression of value or values for metrics within the network data\n */\nexport type Weights = number | number[];\n\n/**\n * Typeguard to ensure value is a Weights type.\n */\nexport function isWeights(val: any): val is Weights {\n  return val && (val.toFixed || Array.isArray(val));\n}\n\n/**\n * Typeguard to ensure value is a weight value object that defines weights for\n * an edge\n */\nexport function isEdgeWeights(val: any): val is { ab: Weights; ba: Weights } {\n  return val && isWeights(val.ab) && isWeights(val.ba);\n}\n\n/**\n * Typeguard to ensure value is a single number and not a list\n */\nexport function isWeightNumber(val: Weights): val is number {\n  return (val as number).toFixed !== void 0;\n}\n\n/**\n * This is the expected value that an identifier should be. Number identifiers\n * perform better.\n */\nexport type Identifier = number | string;\n\n/**\n * Typeguard to ensure a value is an identifier\n */\nexport function isIdentifier(val: any): val is Identifier {\n  return val && (val.toFixed || val.substring);\n}\n\n/**\n * Typeguard for identifiers to determine if it's a string or not\n */\nexport function isIdentifierString(val: Identifier): val is string {\n  return Boolean((val as any).substring);\n}\n\n/**\n * Defines a method or string accessor to retrieve a property. Accessors are\n * also able to access multiples of the same properties.\n */\nexport type Accessor<TSource, TReturn, TMeta> =\n  | ((item: TSource, meta?: TMeta) => TReturn)\n  | keyof TSource;\n\n/**\n * Typeguard for Accessors to determine if it's a simple string access or the\n * method access\n */\nexport function isAccessorString<T, U, V>(\n  val: Accessor<T, U, V>\n): val is keyof T {\n  return Boolean((val as any).substring);\n}\n\n/**\n * An edge represents a path between two nodes and can express value to either\n * direction the edge flows. An edge requires nodes to exist.\n */\nexport interface IEdge<TNodeMeta, TEdgeMeta> {\n  /**\n   * A unique identifier for the edge. A number is preferred for performance and\n   * reduced RAM\n   */\n  id: Identifier;\n  /** One of the nodes the edge connects */\n  a: INode<TNodeMeta, TEdgeMeta>;\n  /** Another node the edge can connect */\n  b: INode<TNodeMeta, TEdgeMeta>;\n  /** The value flowing from node a to node b */\n  atob: Weights;\n  /** The value flowing from node b to node a */\n  btoa: Weights;\n  /** Meta information that can be associated with the Edge */\n  meta?: TEdgeMeta;\n}\n\n/**\n * Typeguard to distinguish between Edges vs Nodes\n */\nexport function isEdge<TNodeMeta, TEdgeMeta>(\n  val?: INode<TNodeMeta, TEdgeMeta> | IEdge<TNodeMeta, TEdgeMeta>\n): val is IEdge<TNodeMeta, TEdgeMeta> {\n  return val && (val as any).a && (val as any).b;\n}\n\n/**\n * An edge who has it's structure locked, but it's values are modifiable.\n */\nexport interface ILockedEdge<TNodeMeta, TEdgeMeta> {\n  /**\n   * A unique identifier for the edge. A number is preferred for performance and\n   * reduced RAM\n   */\n  readonly id: Identifier;\n  /** One of the nodes the edge connects */\n  readonly a: INode<TNodeMeta, TEdgeMeta>;\n  /** Another node the edge can connect */\n  readonly b: INode<TNodeMeta, TEdgeMeta>;\n  /** The value flowing from node a to node b */\n  atob: Weights;\n  /** The value flowing from node b to node a */\n  btoa: Weights;\n  /** Meta information that can be associated with the Edge */\n  meta?: TEdgeMeta;\n}\n\n/**\n * A node represents a data point with a distinct value that can exist as itself\n * that can be connected to other nodes.\n */\nexport interface INode<TNodeMeta, TEdgeMeta> {\n  /**\n   * A unique identifier for the node. A number is preferred for performance and\n   * reduced RAM\n   */\n  id: Identifier;\n  /**\n   * The edges that connects this node to other nodes where edge.b === this node\n   */\n  in: IEdge<TNodeMeta, TEdgeMeta>[];\n  /** Meta information that can be associated with the Node */\n  meta?: TNodeMeta;\n  /**\n   * The edges that connects this node to other nodes where edge.a === this node\n   */\n  out: IEdge<TNodeMeta, TEdgeMeta>[];\n  /** The values that this node harbors */\n  value: Weights;\n}\n\n/**\n * Typeguard to distinguish between Edges vs Nodes\n */\nexport function isNode<TNodeMeta, TEdgeMeta>(\n  val?: INode<TNodeMeta, TEdgeMeta> | IEdge<TNodeMeta, TEdgeMeta>\n): val is INode<TNodeMeta, TEdgeMeta> {\n  return val && (val as any).in && (val as any).out;\n}\n\n/**\n * This is the proper data structure for Networked Data.\n */\nexport interface INetworkData<TNodeMeta, TEdgeMeta> {\n  /** The new node format created for all of the node information */\n  nodes: INode<TNodeMeta, TEdgeMeta>[];\n  /** The lookup used to identify nodes by their identifier */\n  nodeMap: Map<Identifier, INode<TNodeMeta, TEdgeMeta>>;\n  /** The new edge format created for all of the edge information */\n  edges: IEdge<TNodeMeta, TEdgeMeta>[];\n  /** The lookup used to identify edges by their identifier */\n  edgeMap: Map<Identifier, IEdge<TNodeMeta, TEdgeMeta>>;\n  /**\n   * This is a lookup to quickly find existing connections. This only maps\n   * unidirectionally where you always have to check a to b. Checking b to a\n   * would be considered undefined behavior for this list. We do not store btoa\n   * as it would be redundant and a waste of RAM. If you check nodeA to nodeB\n   * for a connection but do not find one, simply reverse the check with this\n   * look up nodeB to nodeA to see if the connection exists.\n   */\n  atobMap: Map<\n    INode<TNodeMeta, TEdgeMeta>,\n    Map<INode<TNodeMeta, TEdgeMeta>, IEdge<TNodeMeta, TEdgeMeta>>\n  >;\n}\n\n/**\n * Represents a highly generic object with any type of value. This should be\n * used primarily to help define generic interfaces.\n */\nexport type PartialObject = { [key: string]: any };\n\n/**\n * These are the type of errors you will encounter while processing the data.\n */\nexport enum MakeNetworkErrorType {\n  /** An identifier happened that is invalid */\n  BAD_ID,\n  /**\n   * A lookup for a node happened, and there was no node found with the\n   * calculated identifier\n   */\n  NODE_NOT_FOUND,\n  /**\n   * Two nodes were found with the same identifier. The most recent node will\n   * be the node preserved\n   */\n  DUPLICATE_NODE_ID,\n  /**\n   * Two edges were found with the same identifier. The most recent edge will\n   * be the node preserved\n   */\n  DUPLICATE_EDGE_ID,\n  /** System failure made an unknown type error */\n  UNKNOWN,\n}\n\n/**\n * This is the structure for an error message from the system.\n */\nexport interface IMakeNetworkError<T, U> {\n  /** The error type discovered */\n  error: MakeNetworkErrorType;\n  /** The data source items that were the culprits in causing the error */\n  source: T | U | T[] | U[] | (T | U)[];\n  /** A readable message to explain the cause of the error */\n  message: string;\n}\n\n/**\n * This is the expected result output from the make network operation.\n */\nexport interface IMakeNetworkResult<T, U, TNodeMeta, TEdgeMeta>\n  extends INetworkData<TNodeMeta, TEdgeMeta> {\n  /** All errors discovered while processing the data from old to new format */\n  errors: IMakeNetworkError<T, U>[] | null;\n}\n\n/**\n * This decribes directionality of how an edge relates to a node. Either\n * outgoing where the edge's a === the node or incoming where the\n * edge's b === the node.\n */\nexport enum FlowDirection {\n  BOTH = 0,\n  OUT,\n  IN,\n}\n\n/**\n * This depicts paths that are generated via chained nodes. The Path is built in\n * reverse, so getting the next node from the map will be the previous step in\n * the path. If you get a node from the map and it returns undefined, the input\n * node is the beginning of the path or is not a part of any known path in this\n * map object.\n */\nexport type ReversePathMap<TNodeMeta, TEdgeMeta> = Map<\n  INode<TNodeMeta, TEdgeMeta>,\n  INode<TNodeMeta, TEdgeMeta>\n>;\n\n/**\n * A managed type is a useful type that mirrors a normal network data object BUT\n * it's properties are locked as readonly. This is useful if you have a manager\n * that handles the node data, but does not allow for the data to be manipulated\n * outside the bounds of the managers methods.\n */\nexport interface IManagedEdge<TNodeMeta, TEdgeMeta>\n  extends IEdge<TNodeMeta, TEdgeMeta> {\n  /**\n   * A unique identifier for the edge. A number is preferred for performance and\n   * reduced RAM\n   */\n  readonly id: Identifier;\n  /** One of the nodes the edge connects */\n  readonly a: IManagedNode<TNodeMeta, TEdgeMeta>;\n  /** Another node the edge can connect */\n  readonly b: IManagedNode<TNodeMeta, TEdgeMeta>;\n  /** The value flowing from node a to node b */\n  readonly atob: Weights;\n  /** The value flowing from node b to node a */\n  readonly btoa: Weights;\n  /** Meta information that can be associated with the Edge */\n  readonly meta?: TEdgeMeta;\n}\n\n/**\n * A managed type is a useful type that mirrors a normal network data object BUT\n * it's properties are locked as readonly. This is useful if you have a manager\n * that handles the node data, but does not allow for the data to be manipulated\n * outside the bounds of the managers methods.\n */\nexport interface IManagedNode<TNodeMeta, TEdgeMeta>\n  extends INode<TNodeMeta, TEdgeMeta> {\n  /**\n   * A unique identifier for the node. A number is preferred for performance and\n   * reduced RAM\n   */\n  readonly id: Identifier;\n  /**\n   * The edges that connects this node to other nodes where edge.b === this node\n   */\n  readonly in: IManagedEdge<TNodeMeta, TEdgeMeta>[];\n  /** Meta information that can be associated with the Node */\n  readonly meta?: TNodeMeta;\n  /**\n   * The edges that connects this node to other nodes where edge.a === this node\n   */\n  readonly out: IManagedEdge<TNodeMeta, TEdgeMeta>[];\n  /** The values that this node harbors */\n  readonly value: Weights;\n}\n\n/**\n * A managed type is a useful type that mirrors a normal network data object BUT\n * it's properties are locked as readonly. This is useful if you have a manager\n * that handles the node data, but does not allow for the data to be manipulated\n * outside the bounds of the managers methods.\n */\nexport interface IManagedNetworkData<TNodeMeta, TEdgeMeta>\n  extends INetworkData<TNodeMeta, TEdgeMeta> {\n  /** The new node format created for all of the node information */\n  readonly nodes: IManagedNode<TNodeMeta, TEdgeMeta>[];\n  /** The lookup used to identify nodes by their identifier */\n  readonly nodeMap: Map<Identifier, IManagedNode<TNodeMeta, TEdgeMeta>>;\n  /** The new edge format created for all of the edge information */\n  readonly edges: IManagedEdge<TNodeMeta, TEdgeMeta>[];\n  /** The lookup used to identify edges by their identifier */\n  readonly edgeMap: Map<Identifier, IManagedEdge<TNodeMeta, TEdgeMeta>>;\n  /**\n   * This is a lookup to quickly find existing connections. This only maps\n   * unidirectionally where you always have to check a to b. Checking b to a\n   * would be considered undefined behavior for this list. We do not store btoa\n   * as it would be redundant and a waste of RAM. If you check nodeA to nodeB\n   * for a connection but do not find one, simply reverse the check with this\n   * look up nodeB to nodeA to see if the connection exists.\n   */\n  readonly atobMap: Map<\n    IManagedNode<TNodeMeta, TEdgeMeta>,\n    Map<IManagedNode<TNodeMeta, TEdgeMeta>, IManagedEdge<TNodeMeta, TEdgeMeta>>\n  >;\n}\n\n/**\n * This represents an input type for operations that reads information about a\n * network but does NOT mutate the network in any fashion.\n */\nexport type AnalyzeNetwork<TNodeMeta, TEdgeMeta> =\n  | INetworkData<TNodeMeta, TEdgeMeta>\n  | IManagedNetworkData<TNodeMeta, TEdgeMeta>;\n\n/**\n * This represents an input type for operations that reads information about\n * a network and WILL mutate the network.\n */\nexport type ProcessNetwork<TNodeMeta, TEdgeMeta> = INetworkData<\n  TNodeMeta,\n  TEdgeMeta\n>;\n\n/**\n * This represents an input type for operations that reads information about\n * nodes but does not mutate the network in any fashion.\n */\nexport type AnalyzeNodes<TNodeMeta, TEdgeMeta> =\n  | INode<TNodeMeta, TEdgeMeta>\n  | INode<TNodeMeta, TEdgeMeta>[]\n  | IManagedNode<TNodeMeta, TEdgeMeta>\n  | IManagedNode<TNodeMeta, TEdgeMeta>[];\n\n/**\n * This represents an input type for operations that reads information about\n * nodes but does not mutate the network in any fashion.\n */\nexport type AnalyzeNodeList<TNodeMeta, TEdgeMeta> =\n  | INode<TNodeMeta, TEdgeMeta>[]\n  | IManagedNode<TNodeMeta, TEdgeMeta>[];\n\n/**\n * This represents an input type for operations that reads information about\n * nodes but does not mutate the network in any fashion.\n */\nexport type AnalyzeNode<TNodeMeta, TEdgeMeta> =\n  | INode<TNodeMeta, TEdgeMeta>\n  | IManagedNode<TNodeMeta, TEdgeMeta>;\n\n/**\n * This represents an input type for operations that reads information about\n * nodes and WILL mutate the network.\n */\nexport type ProcessNodes<TNodeMeta, TEdgeMeta> =\n  | INode<TNodeMeta, TEdgeMeta>\n  | INode<TNodeMeta, TEdgeMeta>[];\n\n/**\n * This represents an input type for operations that reads information about\n * nodes and WILL mutate the network.\n */\nexport type ProcessNodeList<TNodeMeta, TEdgeMeta> = INode<\n  TNodeMeta,\n  TEdgeMeta\n>[];\n\n/**\n * This represents an input type for operations that reads information about\n * nodes and WILL mutate the network.\n */\nexport type ProcessNode<TNodeMeta, TEdgeMeta> = INode<TNodeMeta, TEdgeMeta>;\n\n/**\n * This represents an input type for operations that reads information about\n * edges but does not mutate the network in any fashion.\n */\nexport type AnalyzeEdges<TNodeMeta, TEdgeMeta> =\n  | IEdge<TNodeMeta, TEdgeMeta>\n  | IEdge<TNodeMeta, TEdgeMeta>[]\n  | IManagedEdge<TNodeMeta, TEdgeMeta>\n  | IManagedEdge<TNodeMeta, TEdgeMeta>[];\n\n/**\n * This represents an input type for operations that reads information about\n * edges but does not mutate the network in any fashion.\n */\nexport type AnalyzeEdgeList<TNodeMeta, TEdgeMeta> =\n  | IEdge<TNodeMeta, TEdgeMeta>[]\n  | IManagedEdge<TNodeMeta, TEdgeMeta>[];\n\n/**\n * This represents an input type for operations that reads information about\n * edges but does not mutate the network in any fashion.\n */\nexport type AnalyzeEdge<TNodeMeta, TEdgeMeta> =\n  | IEdge<TNodeMeta, TEdgeMeta>\n  | IManagedEdge<TNodeMeta, TEdgeMeta>;\n\n/**\n * This represents an input type for operations that reads information about\n * edges and WILL mutate the network.\n */\nexport type ProcessEdges<TNodeMeta, TEdgeMeta> =\n  | IEdge<TNodeMeta, TEdgeMeta>\n  | IEdge<TNodeMeta, TEdgeMeta>[];\n\n/**\n * This represents an input type for operations that reads information about\n * edges and WILL mutate the network.\n */\nexport type ProcessEdgeList<TNodeMeta, TEdgeMeta> = IEdge<\n  TNodeMeta,\n  TEdgeMeta\n>[];\n\n/**\n * This represents an input type for operations that reads information about\n * edges and WILL mutate the network.\n */\nexport type ProcessEdge<TNodeMeta, TEdgeMeta> = IEdge<TNodeMeta, TEdgeMeta>;\n","import { IEdge, ProcessEdge, ProcessEdges, ProcessNetwork } from \"../types\";\nimport { makeList } from \"../util/make-list\";\nimport { removeFromMapOfMaps } from \"../util/map-of-maps\";\n\n/**\n * The results of the remove operation.\n */\nexport interface IRemoveEdgeResult<TNodeMeta, TEdgeMeta> {\n  /** The edges successfully remvoed */\n  edges: Set<IEdge<TNodeMeta, TEdgeMeta>>;\n  /** The edges that could not be removed */\n  errors: Set<IEdge<TNodeMeta, TEdgeMeta>> | null;\n}\n\n/**\n * This removes an edge from it's network data structure.\n *\n * Specify removedEdges to prevent errors from being created across multiple edge removals.\n */\nexport function removeEdge<TNodeMeta, TEdgeMeta>(\n  network: ProcessNetwork<TNodeMeta, TEdgeMeta>,\n  edges: ProcessEdges<TNodeMeta, TEdgeMeta>,\n  removedEdges?: Set<ProcessEdge<TNodeMeta, TEdgeMeta>>\n) {\n  // Ensure we are working with a list\n  edges = makeList(edges);\n  // Tracks edges we successfully removed\n  removedEdges = removedEdges || new Set<IEdge<TNodeMeta, TEdgeMeta>>();\n  // Tracks edges that could not be removed\n  const errors = new Set<IEdge<TNodeMeta, TEdgeMeta>>();\n\n  // Processes all edges to be removed\n  for (let i = 0, iMax = edges.length; i < iMax; ++i) {\n    // Get the next edge to process\n    const edge = edges[i];\n    // Get the object we wish to delete to make sure the object specified exists\n    // within the network.\n    const toDelete = network.edgeMap.get(edge.id);\n\n    // If we deleted the edge successfully, then we need to make sure the edge\n    // deleted actually is the SAME edge object we want to delete. Otherwise,\n    // that's an error where we deleted a edge with the same ID, but is NOT an\n    // object truly within the network.\n    if (toDelete) {\n      if (toDelete === edge) {\n        network.edgeMap.delete(edge.id);\n      } else {\n        errors.add(edge);\n        continue;\n      }\n    }\n\n    // If the edge is not within the network dataset, we error based on a bad\n    // edge identifier specified.\n    else {\n      // If we couldn't delete the edge because it wasn't in the network, we\n      // check to see if it was already removed\n      if (!removedEdges.has(edge)) {\n        // If it wasn't removed, this means this edge just didn't exist at all\n        // in this network, thus is an error\n        errors.add(edge);\n      }\n\n      continue;\n    }\n\n    // Safely clean the edge out of it's associated nodes\n    const aIndex = edge.a.out.indexOf(edge);\n    const bIndex = edge.b.in.indexOf(edge);\n    if (aIndex > -1) edge.a.out.splice(aIndex, 1);\n    if (bIndex > -1) edge.b.in.splice(bIndex, 1);\n    // Clean out the edge from the network's listing\n    const edgeIndex = network.edges.indexOf(edge);\n    if (edgeIndex > -1) network.edges.splice(edgeIndex, 1);\n    // Clean out the atob mapping from the network\n    removeFromMapOfMaps(network.atobMap, edge.a, edge.b);\n    // Add the edge to our list of edges that's been removed\n    removedEdges.add(edge);\n  }\n\n  return {\n    edges: removedEdges,\n    errors: errors.size > 0 ? errors : null,\n  };\n}\n","export * from \"./map-of-maps\";\nexport * from \"./make-list\";\nexport * from \"./access\";\nexport * from \"./shallow-list-compare\";\nexport * from \"./random-network\";\nexport * from \"./random\";\nexport * from \"./network-data-manager\";\n","import { IEdge, ProcessEdge, ProcessEdges, ProcessNetwork } from \"../types\";\nimport { makeList } from \"../util/make-list\";\nimport { addToMapOfMaps } from \"../util/map-of-maps\";\n\n/**\n * This contains the information to see which edges were successfully added to\n * the network\n */\nexport interface IAddEdgeResult<TNodeMeta, TEdgeMeta> {\n  /** Successfully added edges */\n  edges: Set<IEdge<TNodeMeta, TEdgeMeta>>;\n  /** Edges that could not be added due to errors */\n  errors: Set<IEdge<TNodeMeta, TEdgeMeta>> | null;\n}\n\n/**\n * Adds an edge to the network and ensures it updates the associated nodes and\n * lookups. The ends of the edge MUST\n * be within the network at the time of executing this method.\n *\n * Provide addedEdges to this method to prevent errors from being reported when\n * multiple similar operations are\n * executed.\n *\n * @param network The network data to add the edges into\n * @param edges The edge or list of edges to add into the network\n * @param addedEdges A list of edges that have already been added. This is a\n *                   context used during add operations to prevent infinite\n *                   loops and ensure an edge is only added once.\n * @param edgeErrors Provides an output set to merge errors for edges into\n */\nexport function addEdge<TNodeMeta, TEdgeMeta>(\n  network: ProcessNetwork<TNodeMeta, TEdgeMeta>,\n  edges: ProcessEdges<TNodeMeta, TEdgeMeta>,\n  addedEdges?: Set<ProcessEdge<TNodeMeta, TEdgeMeta>>,\n  edgeErrors?: Set<ProcessEdge<TNodeMeta, TEdgeMeta>>\n): IAddEdgeResult<TNodeMeta, TEdgeMeta> {\n  // Ensure we process a list\n  edges = makeList(edges);\n  // Tracks list of edges that were added in the operation\n  addedEdges = addedEdges || new Set();\n  // Tracks edges that had an error while trying to add it\n  const errors: Set<IEdge<TNodeMeta, TEdgeMeta>> = edgeErrors || new Set();\n\n  // Process all edge adds that will happen\n  for (let i = 0, iMax = edges.length; i < iMax; ++i) {\n    const edge = edges[i];\n\n    // We do not perform an add if the edge id is already a part of the network\n    if (network.edgeMap.has(edge.id)) {\n      // If this was an edge added from processing added edges then this is not\n      // an error\n      if (!addedEdges.has(edge)) {\n        errors.add(edge);\n      }\n\n      continue;\n    }\n\n    // If the network does not have the edge's a or b nodes, we can not add the\n    // edge in. We also ensure we don't just have a match by id, but the\n    // references must be the SAME OBJECT.\n    const nodeA = network.nodeMap.get(edge.a.id);\n    const nodeB = network.nodeMap.get(edge.b.id);\n\n    if (nodeA !== edge.a || nodeB !== edge.b) {\n      errors.add(edge);\n      continue;\n    }\n\n    // Add the edge to the network\n    network.edges.push(edge);\n    // Add the lookup for the edge\n    network.edgeMap.set(edge.id, edge);\n    // Add the node lookup for the edge\n    addToMapOfMaps(network.atobMap, edge.a, edge.b, edge);\n    // Ensure the edge exists on the nodes it's associated with\n    let edgeIndex = edge.a.out.indexOf(edge);\n    if (edgeIndex < 0) edge.a.out.push(edge);\n    edgeIndex = edge.b.in.indexOf(edge);\n    if (edgeIndex < 0) edge.b.in.push(edge);\n    // Track the edge as being added successfully\n    addedEdges.add(edge);\n  }\n\n  return {\n    edges: addedEdges,\n    errors: errors.size > 0 ? errors : null,\n  };\n}\n","import { Accessor, isAccessorString } from \"../types\";\n\n/**\n * Uses an accessor to access a chunk of data\n */\nexport function access<T, U, V>(\n  data: T,\n  accessor: Accessor<T, U, V> | undefined,\n  guard: (val: any) => val is U,\n  meta?: V\n): U | null {\n  if (accessor) {\n    if (isAccessorString(accessor)) {\n      const val = data[accessor];\n      if (guard(val)) return val;\n    } else {\n      return accessor(data, meta);\n    }\n  }\n\n  return null;\n}\n","import { DataProvider, values } from \"simple-data-provider\";\nimport {\n  Accessor,\n  Identifier,\n  IEdge,\n  IMakeNetworkError,\n  IMakeNetworkResult,\n  INetworkData,\n  INode,\n  isDefined,\n  isEdgeWeights,\n  isIdentifier,\n  isWeightNumber,\n  isWeights,\n  MakeNetworkErrorType,\n  PartialObject,\n  Weights,\n} from \"../types\";\nimport { access } from \"../util/access\";\nimport { makeError } from \"../util/make-error\";\nimport { addToMapOfMaps } from \"../util/map-of-maps\";\nimport { removeEdge } from \"./remove-edge\";\n\n/**\n * These are the modes available for the aggregation procedure.\n */\nexport enum MakeNetworkAggregateValueMode {\n  /**\n   * This is the default: values discovered (whether list or single number) will\n   * simply replace the previously found values.\n   */\n  NONE,\n  /**\n   * DEFINED values discovered will cause overrides for the values at the index\n   * provided. Numbers and arrays are seen as two separate entities and will\n   * fully overrid one another.\n   *\n   * - existing: [1, 2, 3] new: [0, 1] result: [0, 1, 3]\n   * - existing: [1, 2, 3] new: [undefined, 1] result: [1, 1, 3]\n   * - existing: 1 new: [2, 3, 4] result: [2, 3, 4]\n   * - existing: [1, 2, 3] new: 5 result: 5\n   * - exisiting: [undefined, 2, 3] new: [1] result: [1, 2, 3]\n   */\n  OVERRIDE,\n  /**\n   * As values are discovered, they will ALWAYS be concatenated to the end of\n   * the values\n   */\n  CONCAT,\n}\n\n/**\n * Options for generating network data from a flat list of data.\n */\nexport interface IMakeNetworkOptions<\n  TNodeSource,\n  TEdgeSource,\n  TNodeMeta,\n  TEdgeMeta,\n  TNodeInfo extends PartialObject,\n  TEdgeInfo extends PartialObject\n> {\n  /**\n   * Some datasets spread out the total configuration of a node or edge across\n   * multiple rows of data, such as edge connections where it could be two rows\n   * that defines the edge connecting two nodes.\n   *\n   * Easy check to see if this needs to be true: Does an edge or node have all\n   * of it's information spread out across more than one data row? If yes, this\n   * should be true. If data for each node and each edge is located in a single\n   * row, then this should be false.\n   */\n  aggregateResults?: boolean;\n  /**\n   * ONLY IF AGGREGATE RESULTS IS FLAGGED AS TRUE:\n   * When this is set, the values discovered\n   */\n  aggregateValueMode?: MakeNetworkAggregateValueMode;\n  /**\n   * If this is set, the data that originates the nodes and edges will be\n   * deleted as it's consumed. This helps reduce memory pressure and RAM spikes.\n   * This only works for data Arrays and not function callbacks. If you use a\n   * function callback, it is recommended that each callback does NOT retain or\n   * have stored in any form the data passed into this converter.\n   */\n  deleteWhileProcessing?: boolean;\n  /**\n   * The accessor to retrieve the id of the node the edge originates from.\n   * Provides data provided when the identifier was found.\n   *\n   * Accessors are either:\n   *  \"a property key as a string\"\n   * or a callback\n   *  (dataRow) => dataRow.property\n   */\n  edgeA: Accessor<TEdgeSource, Identifier, TEdgeInfo>;\n  /**\n   * The accessor to retrieve the id of the node the edge terminates at.\n   * Provides data provided when the identifier was found.\n   *\n   * Accessors are either:\n   *  \"a property key as a string\"\n   * or a callback\n   *  (dataRow) => dataRow.property\n   */\n  edgeB: Accessor<TEdgeSource, Identifier, TEdgeInfo>;\n  /** The data that needs to be converted to edges */\n  edgeData: DataProvider<TEdgeSource>;\n  /**\n   * The accessor to retrieve the id of edges from the data. This can return a\n   * list of identifiers for the single row of data. This will cause the row of\n   * data to get processed repeatedly for each identifier returned.\n   *\n   * Accessors are either:\n   *\n   * \"a property key as a string\"\n   *\n   * or a callback\n   *\n   * (dataRow) => dataRow.property\n   */\n  edgeId: Accessor<TEdgeSource, Identifier | Identifier[], never>;\n  /**\n   * After identifiers are created, this will associate some form of information\n   * with the identifier provided. This information gets passed into the\n   * accessors of the other edge properties.\n   */\n  edgeInfo?(id: Identifier, idIndex: number, row: TEdgeSource): TEdgeInfo;\n  /**\n   * The accessor to retrieve all properties expected in the meta data of the\n   * edge. Provides data provided when the identifier was found.\n   *\n   * Accessors are either: \"a property key as a string\" or a callback (dataRow)\n   *  => dataRow.property\n   */\n  edgeMeta: Accessor<TEdgeSource, TEdgeMeta, TEdgeInfo>;\n  /**\n   * The accessor to retrieve the Weight values for an edge.\n   * Provides data provided when the identifier was found.\n   *\n   * Accessors are either:\n   *  \"a property key as a string\"\n   * or a callback\n   *  (dataRow) => dataRow.property\n   */\n  edgeValues?: Accessor<\n    TEdgeSource,\n    { ab?: Weights; ba?: Weights } | undefined,\n    TEdgeInfo\n  >;\n  /**\n   * The data that needs to be converted to nodes. This can be provided as a\n   * method for producing the row of data or an async method that may have a\n   * fetch routine to the server to produce the data. Return a falsy value to\n   * stop function callback returns.\n   */\n  nodeData: DataProvider<TNodeSource>;\n  /**\n   * The accessor to retrieve the id of nodes from the data. This can return a\n   * list of identifiers for the single row of data. This will cause the row of\n   * data to get processed repeatedly for each identifier returned.\n   *\n   * Accessors are either: \"a property key as a string\" or a callback (dataRow)\n   *  => dataRow.property\n   */\n  nodeId: Accessor<TNodeSource, Identifier | Identifier[], never>;\n  /**\n   * After identifiers are created, this will associate some form of information\n   * with the identifier provided. This information gets passed into the\n   * accessors of the other node properties.\n   */\n  nodeInfo?(id: Identifier, idIndex: number, row: TNodeSource): TNodeInfo;\n  /**\n   * The accessor to retrieve all properties expected in the meta data of the\n   * node. Provides data provided when the identifier was found.\n   *\n   * Accessors are either: \"a property key as a string\" or a callback (dataRow)\n   *  => dataRow.property\n   */\n  nodeMeta: Accessor<TNodeSource, TNodeMeta, TNodeInfo>;\n  /**\n   * The accessor to retrieve the Weight values for a node.\n   * Provides data provided when the identifier was found.\n   *\n   * Accessors are either:\n   *  \"a property key as a string\"\n   * or a callback\n   *  (dataRow) => dataRow.property\n   */\n  nodeValues?: Accessor<TNodeSource, Weights | undefined, TNodeInfo>;\n  /**\n   * Supply this with a list of errors you wish to ignore. For instance, in some\n   * cases, it may be necessary to have node's with duplicate identifiers.\n   */\n  suppressErrors?: MakeNetworkErrorType[];\n}\n\n/**\n * Performs the correct aggregation strategy for values found during aggregate\n * mode.\n */\nfunction aggregateValue(\n  mode: MakeNetworkAggregateValueMode,\n  oldVal?: Weights,\n  newVal?: Weights\n) {\n  switch (mode) {\n    /**\n     * Always appends defined discovered values. All undefined values will get\n     * stripped out.\n     */\n    case MakeNetworkAggregateValueMode.CONCAT: {\n      if (oldVal === void 0) return newVal;\n      if (newVal === void 0) return oldVal;\n\n      if (isWeightNumber(oldVal)) {\n        return [oldVal].concat(newVal);\n      } else {\n        oldVal.concat(newVal).filter(isDefined);\n      }\n    }\n\n    /**\n     * If the new value is defined, completely replace the old value with the\n     * new one found\n     */\n    case MakeNetworkAggregateValueMode.NONE: {\n      if (newVal === void 0) {\n        return oldVal;\n      }\n      return newVal;\n    }\n\n    /**\n     * If either values are a number a complete override occurs. If both are a\n     * list, then the defined values in the new list will override the values in\n     * the old list at the index the new list specified.\n     */\n    case MakeNetworkAggregateValueMode.OVERRIDE: {\n      if (oldVal === void 0) return newVal;\n      if (newVal === void 0) return oldVal;\n\n      if (isWeightNumber(oldVal) || isWeightNumber(newVal)) {\n        return newVal;\n      }\n\n      const longest = newVal.length > oldVal.length ? newVal : oldVal;\n      const out = new Array(longest.length);\n\n      for (let i = 0, iMax = newVal.length; i < iMax; ++i) {\n        const num = newVal[i];\n        if (num !== void 0) {\n          out[i] = num;\n        } else {\n          out[i] = oldVal[i];\n        }\n      }\n\n      return out;\n    }\n  }\n}\n\n/**\n * This consumes a list of data and processes the objects to become INode's and\n * IEdge's. The goal of this method is to help the processor reduce it's memory\n * footprint of a previous dataset as it grows the new networked dataset.\n *\n * This helps with processing enormous data loads and careful attention should\n * be paid to how you are handling your data. Ensure there are not multiple\n * copies of the data in some way and let it be converted to this new format.\n */\nexport async function makeNetwork<\n  TNodeSource,\n  TEdgeSource,\n  TNodeMeta,\n  TEdgeMeta,\n  TNodePartial extends PartialObject,\n  TEdgePartial extends PartialObject\n>(\n  options: IMakeNetworkOptions<\n    TNodeSource,\n    TEdgeSource,\n    TNodeMeta,\n    TEdgeMeta,\n    TNodePartial,\n    TEdgePartial\n  >\n): Promise<IMakeNetworkResult<TNodeSource, TEdgeSource, TNodeMeta, TEdgeMeta>> {\n  const {\n    aggregateResults,\n    aggregateValueMode = MakeNetworkAggregateValueMode.NONE,\n    edgeA,\n    edgeB,\n    edgeData,\n    edgeId,\n    edgeInfo: edgeInfoForId,\n    edgeMeta,\n    edgeValues,\n    nodeData,\n    nodeId,\n    nodeInfo: nodeInfoForId,\n    nodeMeta,\n    nodeValues,\n    suppressErrors,\n  } = options;\n  const nodes: INode<TNodeMeta, TEdgeMeta>[] = [];\n  const edges: IEdge<TNodeMeta, TEdgeMeta>[] = [];\n  const errors: IMakeNetworkError<TNodeSource, TEdgeSource>[] = [];\n  // This is a node UID that will be used if a UID cannot be determined from the\n  // accessor\n  let nodeUID = 0;\n  // This is an edge UID that will be used if a UID cannot be determined from\n  // the accessor\n  let edgeUID = 0;\n  // Create a lookup to retrieve a node by it's identifier\n  const nodeMap = new Map<Identifier, INode<TNodeMeta, TEdgeMeta>>();\n  // Create a lookup to retrieve an edge by it's identifier\n  const edgeMap = new Map<Identifier, IEdge<TNodeMeta, TEdgeMeta>>();\n  // Make a set from our list of errors to suppress\n  const suppress = new Set(suppressErrors || []);\n  // Create the lookup that stores our atob edge lookup\n  const atobMap: INetworkData<TNodeMeta, TEdgeMeta>[\"atobMap\"] = new Map();\n\n  // This is the new network we're creating\n  const network: IMakeNetworkResult<\n    TNodeSource,\n    TEdgeSource,\n    TNodeMeta,\n    TEdgeMeta\n  > = {\n    nodes,\n    edges,\n    nodeMap,\n    edgeMap,\n    atobMap,\n    errors,\n  };\n\n  // First map our data to node objects\n  for await (const data of values(nodeData)) {\n    // Get the identifier of the node for this particular row of data\n    let idFeedback = access(data, nodeId, isIdentifier) || nodeUID++;\n    if (!Array.isArray(idFeedback)) idFeedback = [idFeedback];\n\n    // List out our identifiers and id info\n    const ids: Identifier[] = [];\n    const infos: (TNodePartial | undefined)[] = [];\n\n    for (let k = 0, kMax = idFeedback.length; k < kMax; ++k) {\n      const check = idFeedback[k];\n      ids.push(check);\n\n      if (nodeInfoForId) {\n        infos.push(nodeInfoForId(check, k, data));\n      } else {\n        infos.push(void 0);\n      }\n    }\n\n    // For all ids found for this given row: we process the row repeatedly per\n    // each id discovered\n    for (let k = 0, kMax = ids.length; k < kMax; ++k) {\n      const id = ids[k];\n      const info = infos[k];\n      // Get the previous node if it exists\n      const previous = nodeMap.get(id);\n      const value: Weights = access(data, nodeValues, isWeights, info) || [];\n      const meta: TNodeMeta | undefined =\n        access(data, nodeMeta, (val: any): val is TNodeMeta => val, info) ||\n        void 0;\n      let node: INode<TNodeMeta, TEdgeMeta> | undefined = void 0;\n\n      // If we're aggregating results, then we modify the existing node for the\n      // node identifier\n      if (aggregateResults) {\n        if (previous) {\n          previous.value =\n            aggregateValue(aggregateValueMode, previous.value, value) || [];\n          previous.meta = Object.assign({}, previous.meta, meta);\n        } else {\n          node = {\n            id,\n            in: [],\n            out: [],\n            value,\n            meta,\n          };\n\n          // Only in the case a new node is generated do we need to add it to\n          // the network object\n          nodes.push(node);\n          nodeMap.set(node.id, node);\n        }\n      }\n\n      // If we're not aggregating results, then we simply make sure the node is\n      // created and create errors for duplicates\n      else {\n        node = {\n          id,\n          in: [],\n          out: [],\n          value,\n          meta,\n        };\n\n        // In non-aggregation mode, finding a second node of the same id is\n        // technically an error and will override the previously found node.\n        if (previous) {\n          makeError(suppress, errors, {\n            error: MakeNetworkErrorType.DUPLICATE_NODE_ID,\n            source: [data, previous],\n            message:\n              \"Two nodes have the same Identifier. This overrides the previous node discovered\",\n          });\n\n          // Remove the previously found node\n          nodes.splice(nodes.indexOf(previous), 1);\n        }\n\n        // Add the node to our network object\n        nodes.push(node);\n        nodeMap.set(node.id, node);\n      }\n    }\n  }\n\n  // This is a map to be used for the aggregation mode to harbor all the edges\n  // being pieced together\n  const partialEdgeMap = new Map<\n    Identifier,\n    [Partial<IEdge<TNodeMeta, TEdgeMeta>>, (TNodeSource | TEdgeSource)[]]\n  >();\n\n  // We now convert our edge data into real edges\n  for await (const data of values(edgeData)) {\n    // Find the edge identifier this data row is associated with\n    let idFeedback = access(data, edgeId, isIdentifier) || edgeUID++;\n    if (!Array.isArray(idFeedback)) idFeedback = [idFeedback];\n\n    // List out our identifiers and id info\n    const ids: Identifier[] = [];\n    const infos: (TEdgePartial | undefined)[] = [];\n\n    for (let k = 0, kMax = idFeedback.length; k < kMax; ++k) {\n      const check = idFeedback[k];\n      ids.push(check);\n\n      if (edgeInfoForId) {\n        infos.push(edgeInfoForId(check, k, data));\n      } else {\n        infos.push(void 0);\n      }\n    }\n\n    // For every id discovered, we need to process the row again\n    for (let k = 0, kMax = ids.length; k < kMax; ++k) {\n      const id = ids[k];\n      const info = infos[k];\n      // Find any nodes associated with this edge\n      const a = access(data, edgeA, isIdentifier, info) || \"\";\n      const b = access(data, edgeB, isIdentifier, info) || \"\";\n      const nodeA = nodeMap.get(a);\n      const nodeB = nodeMap.get(b);\n\n      // Retrieve the values this edge will have assigned to it\n      const values = access(data, edgeValues, isEdgeWeights, info) || {\n        ab: [],\n        ba: [],\n      };\n      // Retrieve the meta information this row contains\n      const meta =\n        access(data, edgeMeta, (val: any): val is TEdgeMeta => val, info) ||\n        undefined;\n\n      // For aggregation, we gather as much edge information as possible for the\n      // provided data row, then we validate each edge after all data has been\n      // processed first.\n      if (aggregateResults) {\n        const previousPair = partialEdgeMap.get(id);\n\n        // If a previous partial edge exists add to and modify it\n        if (previousPair) {\n          const previous = previousPair[0];\n          previousPair[1].push(data);\n\n          if (nodeA) previous.a = nodeA;\n          if (nodeB) previous.b = nodeB;\n\n          if (isWeights(values.ab)) {\n            previous.atob = aggregateValue(\n              aggregateValueMode,\n              previous.atob,\n              values.ab\n            );\n          }\n\n          if (isWeights(values.ba)) {\n            previous.btoa = aggregateValue(\n              aggregateValueMode,\n              previous.btoa,\n              values.ba\n            );\n          }\n\n          previous.meta = Object.assign({}, previous.meta, meta);\n        }\n\n        // Otherwise, create a new edge\n        else {\n          const edge: Partial<IEdge<TNodeMeta, TEdgeMeta>> = {\n            id,\n            a: nodeA,\n            b: nodeB,\n            atob: values.ab,\n            btoa: values.ba,\n            meta,\n          };\n\n          partialEdgeMap.set(id, [edge, []]);\n        }\n      }\n\n      // For non-aggregation, we check for edge duplicate errors and ensure the\n      // provided data row has proper nodes for each end of the edge.\n      else {\n        const previous = edgeMap.get(id);\n\n        // Ensure both nodes can be found for the edge. If not, this is an\n        // invalid edge and will not be a part of the data.\n        if (!nodeA || !nodeB) {\n          makeError(suppress, errors, {\n            error: MakeNetworkErrorType.NODE_NOT_FOUND,\n            source: data,\n            message:\n              !a && !b\n                ? \"Could not find either node for this edge\"\n                : !a\n                ? \"Could not find node a for this edge\"\n                : !b\n                ? \"Could not find node b for this edge\"\n                : \"Error\",\n          });\n\n          continue;\n        }\n\n        // Create the new format edge type\n        const edge: IEdge<TNodeMeta, TEdgeMeta> = {\n          id,\n          a: nodeA,\n          b: nodeB,\n          atob: values.ab || 0,\n          btoa: values.ba || 0,\n          meta,\n        };\n\n        // We must produce errors for duplicate edge identifiers\n        if (previous) {\n          makeError(suppress, errors, {\n            error: MakeNetworkErrorType.DUPLICATE_EDGE_ID,\n            source: [data, previous],\n            message:\n              \"Two edges have the same Identifier. This overrides the previous edge discovered\",\n          });\n\n          // Remove the previous edge from the network\n          removeEdge(network, previous);\n        }\n\n        // Add the edge to the newly created edges\n        edges.push(edge);\n        // Add a lookup for the edge by it's identifier\n        edgeMap.set(edge.id, edge);\n        // Add the edge to it's nodes\n        edge.a.out.push(edge);\n        edge.b.in.push(edge);\n        // Store the atob mapping this edge creates\n        addToMapOfMaps(atobMap, edge.a, edge.b, edge);\n      }\n    }\n  }\n\n  // In aggregation mode for edges, we have one final pass: analyze all of the\n  // partial edges we have accumulated and determine which ones are valid edges.\n  // We will error on edges partially created that do not properly represent a\n  // connection within the network\n  if (aggregateResults) {\n    partialEdgeMap.forEach((pair) => {\n      const edge = pair[0];\n      const data = pair[1];\n\n      // Validate the ID\n      if (!edge.id) {\n        makeError(suppress, errors, {\n          error: MakeNetworkErrorType.BAD_ID,\n          source: data,\n          message: \"An edge was generated that has an invalid ID\",\n        });\n\n        return;\n      }\n\n      // Validate that a connection exists\n      if (!edge.a || !edge.b) {\n        const a = edge.a;\n        const b = edge.b;\n\n        makeError(suppress, errors, {\n          error: MakeNetworkErrorType.NODE_NOT_FOUND,\n          source: data,\n          message:\n            !a && !b\n              ? \"Could not find either node for this edge\"\n              : !a\n              ? \"Could not find node a for this edge\"\n              : !b\n              ? \"Could not find node b for this edge\"\n              : \"Error\",\n        });\n\n        return;\n      }\n\n      // Make our edge object that will really be there\n      const newEdge: IEdge<TNodeMeta, TEdgeMeta> = {\n        id: edge.id,\n        a: edge.a,\n        b: edge.b,\n        atob: edge.atob || [],\n        btoa: edge.btoa || [],\n        meta: edge.meta,\n      };\n\n      // Add the new edge to the network\n      // Add the edge to the newly created edges\n      edges.push(newEdge);\n      // Add a lookup for the edge by it's identifier\n      edgeMap.set(newEdge.id, newEdge);\n      // Add the edge to it's nodes\n      newEdge.a.out.push(newEdge);\n      newEdge.b.in.push(newEdge);\n      // Store the atob mapping this edge creates\n      addToMapOfMaps(atobMap, newEdge.a, newEdge.b, newEdge);\n\n      edgeMap.set(newEdge.id, newEdge);\n    });\n  }\n\n  return network;\n}\n","import { AnalyzeNetwork, AnalyzeNode, IEdge } from \"../types\";\nimport { getFromMapOfMaps } from \"../util/map-of-maps\";\n\n/**\n * This checks the network to see if a connection exists between two nodes. If\n * one does not exist, then this returns null.\n *\n * The network object is not required to find a result, but will speed this\n * method up considerably if you plan on calling it in large volumes.\n *\n * The nodes MUST be a part of a VALID network data object. If not, the behavior\n * of this method is undefined.\n */\nexport function getEdge<TNodeMeta, TEdgeMeta>(\n  a: AnalyzeNode<TNodeMeta, TEdgeMeta>,\n  b: AnalyzeNode<TNodeMeta, TEdgeMeta>,\n  network?: AnalyzeNetwork<TNodeMeta, TEdgeMeta>\n): IEdge<TNodeMeta, TEdgeMeta> | undefined {\n  // If the network is provided, do the super speedy lookup\n  if (network) {\n    const atob = getFromMapOfMaps(network.atobMap, a, b);\n    if (atob) return atob;\n    return getFromMapOfMaps(network.atobMap, b, a);\n  }\n\n  // If no network is provided, we must look through the node's flows to get the\n  // edge. We only have to look at the in and out of a single node, as we assume\n  // these nodes originate from a valid Network Data object.\n  let edge = a.in.find((edge) => edge.a === b);\n  if (!edge) edge = a.out.find((edge) => edge.b === b);\n  return edge;\n}\n","export * from \"./compare\";\nexport * from \"./get-edge\";\nexport * from \"./has-circular-edge\";\nexport * from \"./has-node\";\nexport * from \"./max-weight\";\nexport * from \"./min-weight\";\nexport * from \"./node-weight-range\";\nexport * from \"./weight-at-index\";\n","import { AnalyzeEdge, Identifier, IEdge } from \"../types\";\n\n/**\n * Makes a new edge with the same properties as the input. You can optionally make a new identifier for the clones element.\n */\nexport function cloneEdge<TNodeMeta, TEdgeMeta>(\n  a: AnalyzeEdge<TNodeMeta, TEdgeMeta>,\n  id?: Identifier\n): IEdge<TNodeMeta, TEdgeMeta> {\n  return {\n    id: id !== void 0 ? id : a.id,\n    a: a.a,\n    b: a.b,\n    atob: Array.isArray(a.atob) ? a.atob.slice(0) : a.atob,\n    btoa: Array.isArray(a.btoa) ? a.btoa.slice(0) : a.btoa,\n    meta: a.meta,\n  };\n}\n","import { AnalyzeNode, Identifier, INode } from \"../types\";\n\n/**\n * This method copies a node into a new node object. You can optionally set a new id for the newly created node.\n */\nexport function cloneNode<TNodeMeta, TEdgeMeta>(\n  a: AnalyzeNode<TNodeMeta, TEdgeMeta>,\n  id?: Identifier\n): INode<TNodeMeta, TEdgeMeta> {\n  return {\n    id: id !== void 0 ? id : a.id,\n    in: a.in.slice(0),\n    out: a.out.slice(0),\n    value: Array.isArray(a.value) ? a.value.slice(0) : a.value,\n    meta: a.meta,\n  };\n}\n","export * from \"./all-edges\";\nexport * from \"./neighbors\";\nexport * from \"./no-connections\";\nexport * from \"./ripple-select\";\nexport * from \"./shared-connection\";\nexport * from \"./shared-connection\";\nexport * from \"./travel-collision-path\";\nexport * from \"./travel-path\";\n\n// TODO: Path needs to be completed before exporting it to the library\n// export * from \"./path\";\n","import { ILockedEdge, INetworkData, INode, ProcessNetwork } from \"../types\";\nimport { addToMapOfMaps, getFromMapOfMaps } from \"../util/map-of-maps\";\nimport { addEdge } from \"./add-edge\";\nimport { removeEdge } from \"./remove-edge\";\n\n/**\n * This examines the network and lets you combine edge information for edges that share the same a to b connection.\n * This makes your network information a lot cleaner and easier to manipulate. You can store the multiple edge\n * information into the edge's meta data and value weights.\n *\n * It is highly recommended to run this on your network data if you suspect duplicate edges have been created.\n *\n * If you are positive your network edges are clean, then you can save some processing by not running this.\n */\nexport function combineSharedEdges<TNodeMeta, TEdgeMeta>(\n  network: ProcessNetwork<TNodeMeta, TEdgeMeta>,\n  reduce: (\n    edgeA: ILockedEdge<TNodeMeta, TEdgeMeta>,\n    edgeB: ILockedEdge<TNodeMeta, TEdgeMeta>\n  ) => ILockedEdge<TNodeMeta, TEdgeMeta>\n): INetworkData<TNodeMeta, TEdgeMeta> {\n  const found = new Map<\n    INode<TNodeMeta, TEdgeMeta>,\n    Map<INode<TNodeMeta, TEdgeMeta>, ILockedEdge<TNodeMeta, TEdgeMeta>>\n  >();\n  const edges = network.edges.slice(0);\n\n  for (let i = 0, iMax = edges.length; i < iMax; ++i) {\n    const edge = edges[i];\n    let previous = getFromMapOfMaps(found, edge.a, edge.b);\n    if (!previous) previous = getFromMapOfMaps(found, edge.b, edge.a);\n\n    if (previous) {\n      const combined = reduce(previous, edge);\n      removeEdge(network, previous);\n      removeEdge(network, edge);\n      addEdge(network, combined);\n      addToMapOfMaps(found, combined.a, combined.b, combined);\n    } else {\n      addToMapOfMaps(found, edge.a, edge.b, edge);\n    }\n  }\n\n  return network;\n}\n","!function(e,r){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=r():\"function\"==typeof define&&define.amd?define([],r):\"object\"==typeof exports?exports[\"simple-data-provider\"]=r():e[\"simple-data-provider\"]=r()}(\"undefined\"!=typeof self?self:this,(function(){return function(e){var r={};function t(n){if(r[n])return r[n].exports;var o=r[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,t),o.l=!0,o.exports}return t.m=e,t.c=r,t.d=function(e,r,n){t.o(e,r)||Object.defineProperty(e,r,{enumerable:!0,get:n})},t.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},t.t=function(e,r){if(1&r&&(e=t(e)),8&r)return e;if(4&r&&\"object\"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(t.r(n),Object.defineProperty(n,\"default\",{enumerable:!0,value:e}),2&r&&\"string\"!=typeof e)for(var o in e)t.d(n,o,function(r){return e[r]}.bind(null,o));return n},t.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(r,\"a\",r),r},t.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},t.p=\"\",t(t.s=0)}([function(e,r,t){\"use strict\";function n(e){for(var t in e)r.hasOwnProperty(t)||(r[t]=e[t])}Object.defineProperty(r,\"__esModule\",{value:!0}),n(t(1)),n(t(2)),n(t(4))},function(e,r,t){\"use strict\";Object.defineProperty(r,\"__esModule\",{value:!0})},function(e,r,t){\"use strict\";var n=this&&this.__generator||function(e,r){var t,n,o,u,s={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return u={next:a(0),throw:a(1),return:a(2)},\"function\"==typeof Symbol&&(u[Symbol.iterator]=function(){return this}),u;function a(u){return function(a){return function(u){if(t)throw new TypeError(\"Generator is already executing.\");for(;s;)try{if(t=1,n&&(o=2&u[0]?n.return:u[0]?n.throw||((o=n.return)&&o.call(n),0):n.next)&&!(o=o.call(n,u[1])).done)return o;switch(n=0,o&&(u=[2&u[0],o.value]),u[0]){case 0:case 1:o=u;break;case 4:return s.label++,{value:u[1],done:!1};case 5:s.label++,n=u[1],u=[0];continue;case 7:u=s.ops.pop(),s.trys.pop();continue;default:if(!(o=s.trys,(o=o.length>0&&o[o.length-1])||6!==u[0]&&2!==u[0])){s=0;continue}if(3===u[0]&&(!o||u[1]>o[0]&&u[1]<o[3])){s.label=u[1];break}if(6===u[0]&&s.label<o[1]){s.label=o[1],o=u;break}if(o&&s.label<o[2]){s.label=o[2],s.ops.push(u);break}o[2]&&s.ops.pop(),s.trys.pop();continue}u=r.call(e,s)}catch(e){u=[6,e],n=0}finally{t=o=0}if(5&u[0])throw u[1];return{value:u[0]?u[1]:void 0,done:!0}}([u,a])}}},o=this&&this.__await||function(e){return this instanceof o?(this.v=e,this):new o(e)},u=this&&this.__asyncValues||function(e){if(!Symbol.asyncIterator)throw new TypeError(\"Symbol.asyncIterator is not defined.\");var r,t=e[Symbol.asyncIterator];return t?t.call(e):(e=\"function\"==typeof a?a(e):e[Symbol.iterator](),r={},n(\"next\"),n(\"throw\"),n(\"return\"),r[Symbol.asyncIterator]=function(){return this},r);function n(t){r[t]=e[t]&&function(r){return new Promise((function(n,o){(function(e,r,t,n){Promise.resolve(n).then((function(r){e({value:r,done:t})}),r)})(n,o,(r=e[t](r)).done,r.value)}))}}},s=this&&this.__asyncGenerator||function(e,r,t){if(!Symbol.asyncIterator)throw new TypeError(\"Symbol.asyncIterator is not defined.\");var n,u=t.apply(e,r||[]),s=[];return n={},a(\"next\"),a(\"throw\"),a(\"return\"),n[Symbol.asyncIterator]=function(){return this},n;function a(e){u[e]&&(n[e]=function(r){return new Promise((function(t,n){s.push([e,r,t,n])>1||c(e,r)}))})}function c(e,r){try{(t=u[e](r)).value instanceof o?Promise.resolve(t.value.v).then(i,l):f(s[0][2],t)}catch(e){f(s[0][3],e)}var t}function i(e){c(\"next\",e)}function l(e){c(\"throw\",e)}function f(e,r){e(r),s.shift(),s.length&&c(s[0][0],s[0][1])}},a=this&&this.__values||function(e){var r=\"function\"==typeof Symbol&&Symbol.iterator,t=r&&e[r],n=0;if(t)return t.call(e);if(e&&\"number\"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(r?\"Object is not iterable.\":\"Symbol.iterator is not defined.\")};Object.defineProperty(r,\"__esModule\",{value:!0});var c=t(3);function i(e){return function(e){return Array.isArray(e)}(e)?c.ProviderType.LIST:function(e){return void 0!==e.constructor&&(e.constructor===Set||e.constructor===Map)}(e)?c.ProviderType.SET:function(e){return\"function\"==typeof e[Symbol.iterator]}(e)?c.ProviderType.ITERATOR:function(e){return\"function\"==typeof e[Symbol.asyncIterator]}(e)?c.ProviderType.ITERATOR_ASYNC:function(e){return\"object\"==typeof e}(e)?c.ProviderType.OBJECT:function(e){return\"function\"==typeof e}(e)?c.ProviderType.METHOD:c.ProviderType.UNKNOWN}function l(e){return{type:i(e)}}r.values=function(e){return s(this,arguments,(function(){var r,t,s,i,f,y,d,p,v,b,h,T,E,S,O,_,w,P,m,N,R;return n(this,(function(n){switch(n.label){case 0:switch(r=l(e),r.type){case c.ProviderType.LIST:return[3,1];case c.ProviderType.ITERATOR:return[3,8];case c.ProviderType.ITERATOR_ASYNC:return[3,23];case c.ProviderType.SET:return[3,39];case c.ProviderType.OBJECT:return[3,45];case c.ProviderType.METHOD:return[3,52];case c.ProviderType.UNKNOWN:return[3,97];case c.ProviderType.METHOD_SYNC:case c.ProviderType.METHOD_ASYNC:case c.ProviderType.GENERATOR:case c.ProviderType.GENERATOR_ASYNC:return[3,101]}return[3,103];case 1:w=0,h=(t=e).length,n.label=2;case 2:return w<h?[4,o(t[w])]:[3,6];case 3:return[4,n.sent()];case 4:n.sent(),n.label=5;case 5:return++w,[3,2];case 6:return[4,o(void 0)];case 7:return[2,n.sent()];case 8:if(!(S=e).next)return[3,13];_=S.next(),n.label=9;case 9:return _.done?[3,12]:[4,o(_.value)];case 10:return[4,n.sent()];case 11:return n.sent(),_=S.next(),[3,9];case 12:return[3,21];case 13:n.trys.push([13,19,20,21]),s=a(S),i=s.next(),n.label=14;case 14:return i.done?[3,18]:(_=i.value,[4,o(_)]);case 15:return[4,n.sent()];case 16:n.sent(),n.label=17;case 17:return i=s.next(),[3,14];case 18:return[3,21];case 19:return f=n.sent(),P={error:f},[3,21];case 20:try{i&&!i.done&&(m=s.return)&&m.call(s)}finally{if(P)throw P.error}return[7];case 21:return[4,o(void 0)];case 22:return[2,n.sent()];case 23:S=e,n.label=24;case 24:n.trys.push([24,31,32,37]),y=u(S),n.label=25;case 25:return[4,o(y.next())];case 26:return(d=n.sent()).done?[3,30]:(_=d.value,[4,o(_)]);case 27:return[4,n.sent()];case 28:n.sent(),n.label=29;case 29:return[3,25];case 30:return[3,37];case 31:return p=n.sent(),N={error:p},[3,37];case 32:return n.trys.push([32,,35,36]),d&&!d.done&&(R=y.return)?[4,o(R.call(y))]:[3,34];case 33:n.sent(),n.label=34;case 34:return[3,36];case 35:if(N)throw N.error;return[7];case 36:return[7];case 37:return[4,o(void 0)];case 38:return[2,n.sent()];case 39:S=e.values(),_=S.next(),n.label=40;case 40:return _.done?[3,43]:[4,o(_.value)];case 41:return[4,n.sent()];case 42:return n.sent(),_=S.next(),[3,40];case 43:return[4,o(void 0)];case 44:return[2,n.sent()];case 45:v=e,b=Object.values(v),w=0,h=b.length,n.label=46;case 46:return w<h?[4,o(b[w])]:[3,50];case 47:return[4,n.sent()];case 48:n.sent(),n.label=49;case 49:return++w,[3,46];case 50:return[4,o(void 0)];case 51:return[2,n.sent()];case 52:return void 0!==(E=(T=e)(0))?[3,54]:[4,o(void 0)];case 53:return[2,n.sent()];case 54:return c.isIterable(E)?(r.type=c.ProviderType.GENERATOR,[3,63]):[3,55];case 55:return c.isAsyncIterable(E)?(r.type=c.ProviderType.GENERATOR_ASYNC,[3,63]):[3,56];case 56:return E instanceof Promise?(r.type=c.ProviderType.METHOD_ASYNC,[4,o(E)]):[3,60];case 57:return[4,o.apply(void 0,[n.sent()])];case 58:return[4,n.sent()];case 59:return n.sent(),[3,63];case 60:return r.type=c.ProviderType.METHOD_SYNC,[4,o(E)];case 61:return[4,n.sent()];case 62:n.sent(),n.label=63;case 63:switch(r.type){case c.ProviderType.GENERATOR:return[3,64];case c.ProviderType.GENERATOR_ASYNC:return[3,70];case c.ProviderType.METHOD_ASYNC:return[3,78];case c.ProviderType.METHOD_SYNC:return[3,87]}return[3,95];case 64:O=-1,_=(S=E).next(++O),n.label=65;case 65:return _.done?[3,68]:[4,o(_.value)];case 66:return[4,n.sent()];case 67:return n.sent(),_=S.next(++O),[3,65];case 68:return[4,o(void 0)];case 69:return[2,n.sent()];case 70:return O=-1,[4,o((S=E).next(++O))];case 71:_=n.sent(),n.label=72;case 72:return _.done?[3,76]:[4,o(_.value)];case 73:return[4,n.sent()];case 74:return n.sent(),[4,o(S.next(++O))];case 75:return _=n.sent(),[3,72];case 76:return[4,o(void 0)];case 77:return[2,n.sent()];case 78:w=0,n.label=79;case 79:return void 0===E?[3,85]:[4,o(T(++w))];case 80:return void 0!==(E=n.sent())?[3,82]:[4,o(void 0)];case 81:return[2,n.sent()];case 82:return[4,o(E)];case 83:return[4,n.sent()];case 84:return n.sent(),[3,79];case 85:return[4,o(void 0)];case 86:return[2,n.sent()];case 87:w=0,n.label=88;case 88:return void 0===E?[3,93]:void 0!==(E=T(++w))?[3,90]:[4,o(void 0)];case 89:return[2,n.sent()];case 90:return[4,o(E)];case 91:return[4,n.sent()];case 92:return n.sent(),[3,88];case 93:return[4,o(void 0)];case 94:return[2,n.sent()];case 95:return console.warn(\"The provider could not have it's type determined for iteration. Thus no values will be returned.\"),[4,o(void 0)];case 96:return[2,n.sent()];case 97:return[4,o(e)];case 98:return[4,n.sent()];case 99:return n.sent(),[4,o(void 0)];case 100:return[2,n.sent()];case 101:return console.warn(\"Undefined behavior occurred while processing a provider. No values will be returned.\"),[4,o(void 0)];case 102:return[2,n.sent()];case 103:return console.warn(\"The provider could not have it's type properly determined for iteration. Thus no values will be returned.\"),[4,o(void 0)];case 104:return[2,n.sent()]}}))}))}},function(e,r,t){\"use strict\";Object.defineProperty(r,\"__esModule\",{value:!0}),function(e){e[e.LIST=0]=\"LIST\",e[e.METHOD=1]=\"METHOD\",e[e.METHOD_SYNC=2]=\"METHOD_SYNC\",e[e.METHOD_ASYNC=3]=\"METHOD_ASYNC\",e[e.GENERATOR=4]=\"GENERATOR\",e[e.GENERATOR_ASYNC=5]=\"GENERATOR_ASYNC\",e[e.ITERATOR=6]=\"ITERATOR\",e[e.ITERATOR_ASYNC=7]=\"ITERATOR_ASYNC\",e[e.OBJECT=8]=\"OBJECT\",e[e.PRIMITIVE=9]=\"PRIMITIVE\",e[e.SET=10]=\"SET\",e[e.UNKNOWN=11]=\"UNKNOWN\"}(r.ProviderType||(r.ProviderType={})),r.isIterable=function(e){return!!e&&\"function\"==typeof e[Symbol.iterator]},r.isAsyncIterable=function(e){return!!e&&\"function\"==typeof e[Symbol.asyncIterator]}},function(e,r,t){\"use strict\";var n=this&&this.__awaiter||function(e,r,t,n){return new(t||(t=Promise))((function(o,u){function s(e){try{c(n.next(e))}catch(e){u(e)}}function a(e){try{c(n.throw(e))}catch(e){u(e)}}function c(e){var r;e.done?o(e.value):(r=e.value,r instanceof t?r:new t((function(e){e(r)}))).then(s,a)}c((n=n.apply(e,r||[])).next())}))},o=this&&this.__generator||function(e,r){var t,n,o,u,s={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return u={next:a(0),throw:a(1),return:a(2)},\"function\"==typeof Symbol&&(u[Symbol.iterator]=function(){return this}),u;function a(u){return function(a){return function(u){if(t)throw new TypeError(\"Generator is already executing.\");for(;s;)try{if(t=1,n&&(o=2&u[0]?n.return:u[0]?n.throw||((o=n.return)&&o.call(n),0):n.next)&&!(o=o.call(n,u[1])).done)return o;switch(n=0,o&&(u=[2&u[0],o.value]),u[0]){case 0:case 1:o=u;break;case 4:return s.label++,{value:u[1],done:!1};case 5:s.label++,n=u[1],u=[0];continue;case 7:u=s.ops.pop(),s.trys.pop();continue;default:if(!(o=s.trys,(o=o.length>0&&o[o.length-1])||6!==u[0]&&2!==u[0])){s=0;continue}if(3===u[0]&&(!o||u[1]>o[0]&&u[1]<o[3])){s.label=u[1];break}if(6===u[0]&&s.label<o[1]){s.label=o[1],o=u;break}if(o&&s.label<o[2]){s.label=o[2],s.ops.push(u);break}o[2]&&s.ops.pop(),s.trys.pop();continue}u=r.call(e,s)}catch(e){u=[6,e],n=0}finally{t=o=0}if(5&u[0])throw u[1];return{value:u[0]?u[1]:void 0,done:!0}}([u,a])}}},u=this&&this.__asyncValues||function(e){if(!Symbol.asyncIterator)throw new TypeError(\"Symbol.asyncIterator is not defined.\");var r,t=e[Symbol.asyncIterator];return t?t.call(e):(e=\"function\"==typeof __values?__values(e):e[Symbol.iterator](),r={},n(\"next\"),n(\"throw\"),n(\"return\"),r[Symbol.asyncIterator]=function(){return this},r);function n(t){r[t]=e[t]&&function(r){return new Promise((function(n,o){(function(e,r,t,n){Promise.resolve(n).then((function(r){e({value:r,done:t})}),r)})(n,o,(r=e[t](r)).done,r.value)}))}}};Object.defineProperty(r,\"__esModule\",{value:!0}),r.retrieve=function(e,r){var t,s,a,c;return n(this,void 0,void 0,(function(){var n,i;return o(this,(function(o){switch(o.label){case 0:o.trys.push([0,5,6,11]),t=u(e),o.label=1;case 1:return[4,t.next()];case 2:if((s=o.sent()).done)return[3,4];n=s.value,r(n),o.label=3;case 3:return[3,1];case 4:return[3,11];case 5:return i=o.sent(),a={error:i},[3,11];case 6:return o.trys.push([6,,9,10]),s&&!s.done&&(c=t.return)?[4,c.call(t)]:[3,8];case 7:o.sent(),o.label=8;case 8:return[3,10];case 9:if(a)throw a.error;return[7];case 10:return[7];case 11:return[2]}}))}))}}])}));\n//# sourceMappingURL=index.js.map","import { IMakeNetworkError, MakeNetworkErrorType } from \"../types\";\n\n/**\n * Handles generating and suppressing an error.\n */\nexport function makeError<T, U>(\n  suppress: Set<MakeNetworkErrorType>,\n  errors: IMakeNetworkError<T, U>[],\n  error: IMakeNetworkError<T, U>\n) {\n  if (suppress.has(error.error)) return;\n  errors.push(error);\n}\n","type Rand = (range: number) => number;\n\n/** Get a random item from a list */\nexport function randItem<T>(rand: Rand, list: T[]): T {\n  return list[rand(list.length)];\n}\n\n/**\n * This produces a list of randomized numbers (length of 'count') that will sum together to be the 'total'.\n */\nexport function randomSum(rand: Rand, total: number, count: number) {\n  const picks = count;\n  const n = total + picks - 1;\n  const r = [];\n  const rSet = new Set();\n\n  for (let i = 0; i < picks - 1; ++i) {\n    let num = rand(n - 1 + 1);\n    while (rSet.has(num)) num = rand(n - 1 + 1);\n    r.push(num);\n    rSet.add(num);\n  }\n\n  r.sort((a, b) => a - b);\n  const choices = [];\n\n  for (let i = 0; i < picks - 1; ++i) {\n    let sum = r[i];\n\n    if (i > 0) {\n      sum -= r[i - 1];\n    }\n\n    choices.push(sum - 1);\n  }\n\n  choices.push(n - r[r.length - 1]);\n\n  return choices;\n}\n\n/**\n * Get two random items from a list that are both different. Returns null when not enough items available. This works\n * for Objects (Object, Function) NOT traditional primitives (string, number)\n */\nexport function exclusiveRandItems<T>(\n  rand: Rand,\n  list: T[],\n  count: number\n): T[] | null {\n  // We return null here as there are not enough items to make an exclusive list of 'count' length.\n  if (list.length < count) return null;\n  // If the count length is as long as the list, then we just return the entire list.\n  if (list.length === count) return list.slice(0);\n\n  // In this case, it is faster to randomly pick elements to exclude\n  if (list.length - count < count) {\n    const pick = randomSum(rand, list.length, list.length - count);\n    const out = list.slice(0);\n    const toRemove: number[] = [];\n\n    pick.reduce((p, n) => {\n      const index = p + n;\n      toRemove.push(index);\n      return index;\n    }, 0);\n\n    for (let i = toRemove.length - 1; i >= 0; --i) {\n      const index = toRemove[i];\n      out.slice(index, 1);\n    }\n\n    return out;\n  }\n\n  // Otherwise, do the traditional pick random items to include\n  else {\n    const out: T[] = [];\n    const pick = randomSum(rand, list.length - 1, count + 1).map((v) =>\n      v < 0 ? 0 : v >= list.length ? list.length - 1 : v\n    );\n    pick.pop();\n    pick.reduce((p, n) => {\n      const index = p + n;\n      out.push(list[index]);\n      return index;\n    }, 0);\n\n    return out;\n  }\n}\n","import {\n  IEdge,\n  INode,\n  ProcessEdge,\n  ProcessNetwork,\n  ProcessNode,\n  ProcessNodes,\n} from \"../types\";\nimport { makeList } from \"../util/make-list\";\nimport { addEdge } from \"./add-edge\";\n\n/**\n * This contains the information to see which nodes were successfully added to the network as well as new edges\n */\nexport interface IAddNodeResult<TNodeMeta, TEdgeMeta> {\n  /** Successfully added nodes */\n  nodes: Set<INode<TNodeMeta, TEdgeMeta>>;\n  /** Successfully added edges */\n  edges: Set<IEdge<TNodeMeta, TEdgeMeta>>;\n  /** Nodes that had errors while adding */\n  errors: {\n    nodes: Set<INode<TNodeMeta, TEdgeMeta>> | null;\n    edges: Set<IEdge<TNodeMeta, TEdgeMeta>> | null;\n  };\n}\n\n/**\n * Adds a node into a network. This WILL add any edges associated with the node if both ends of the edge are in the\n * network, or is being added into the network during this operation.\n * This ensures all edges and lookups are updated properly.\n *\n * @param network The network data to add the nodes into\n * @param nodes The node or list of nodes to add into the network\n * @param addedNodes A list of nodes that have already been added. This is a context used during add operations to\n *                   prevent infinite loops and ensure a node is only added once.\n * @param addedEdges A list of edges that have already been added. This is a context used during add operations to\n *                   prevent infinite loops and ensure an edge is only added once.\n */\nexport function addNode<TNodeMeta, TEdgeMeta>(\n  network: ProcessNetwork<TNodeMeta, TEdgeMeta>,\n  nodes: ProcessNodes<TNodeMeta, TEdgeMeta>,\n  addedNodes?: Set<ProcessNode<TNodeMeta, TEdgeMeta>>,\n  addedEdges?: Set<ProcessEdge<TNodeMeta, TEdgeMeta>>\n): IAddNodeResult<TNodeMeta, TEdgeMeta> {\n  // Ensure we're working with a list\n  nodes = makeList(nodes);\n  // Ensure we have a set to record newly added nodes\n  addedNodes = addedNodes || new Set();\n  // Create a set to track newly added edges\n  addedEdges = addedEdges || new Set();\n  // Create a set to track errors found during the adding process.\n  const errors: Set<INode<TNodeMeta, TEdgeMeta>> = new Set();\n  // Create a set to track errors found during the add process for edges\n  const edgeErrors: Set<IEdge<TNodeMeta, TEdgeMeta>> = new Set();\n  // This is a list of nodes that should have their edges added in\n  const needsEdges: INode<TNodeMeta, TEdgeMeta>[] = [];\n\n  // Process all of the nodes to be added\n  for (let i = 0, iMax = nodes.length; i < iMax; ++i) {\n    const node = nodes[i];\n\n    // If the node's id already exists, the node specified can not be re-added\n    if (network.nodeMap.has(node.id)) {\n      // If this was a node added from processing added edges then this is not an error\n      if (!addedNodes.has(node)) {\n        errors.add(node);\n      }\n\n      continue;\n    }\n\n    // Add the node to the network\n    network.nodes.push(node);\n    network.nodeMap.set(node.id, node);\n    addedNodes.add(node);\n    needsEdges.push(node);\n  }\n\n  // To make adding edges in more true to adding in our new nodes, we add in edges AFTER all new nodes are added\n  // Otherwise, some edges would not get added if they were built upon the nodes that are being added now\n  for (let i = 0, iMax = needsEdges.length; i < iMax; ++i) {\n    const node = needsEdges[i];\n    // Validate the edges directionality relative to this node\n    // Examine the node's edges to establish all necessary links\n    addEdge(network, node.out, addedEdges, edgeErrors);\n    addEdge(network, node.in, addedEdges, edgeErrors);\n  }\n\n  return {\n    nodes: addedNodes,\n    edges: addedEdges,\n    errors: {\n      nodes: errors,\n      edges: edgeErrors,\n    },\n  };\n}\n","import {\n  INode,\n  ProcessEdge,\n  ProcessNetwork,\n  ProcessNode,\n  ProcessNodes,\n} from \"../types\";\nimport { makeList } from \"../util/make-list\";\nimport { removeEdge } from \"./remove-edge\";\n\n/**\n * This contains the information to see which nodes were successfully removed\n * from the network as well as edges\n */\nexport interface IRemoveNodeResult<TNodeMeta, TEdgeMeta> {\n  /** List of nodes removed during the operation */\n  nodes: Set<ProcessNode<TNodeMeta, TEdgeMeta>>;\n  /** List of edges removed during the operation */\n  edges: Set<ProcessEdge<TNodeMeta, TEdgeMeta>>;\n  /** List of nodes that could not be removed during the operation */\n  errors: Set<ProcessNode<TNodeMeta, TEdgeMeta>> | null;\n}\n\n/**\n * Removes a node from a network and cleans out the edges linking the node to\n * other nodes.\n */\nexport function removeNode<TNodeMeta, TEdgeMeta>(\n  network: ProcessNetwork<TNodeMeta, TEdgeMeta>,\n  nodes: ProcessNodes<TNodeMeta, TEdgeMeta>,\n  removedNodes?: Set<ProcessNode<TNodeMeta, TEdgeMeta>>,\n  removedEdges?: Set<ProcessEdge<TNodeMeta, TEdgeMeta>>\n) {\n  // Ensure this is a list\n  nodes = makeList(nodes);\n  // Track all edges removed so we don't perform extra removals unnecessarily\n  removedEdges = removedEdges || new Set();\n  // Track all nodes successfully removed\n  removedNodes = removedNodes || new Set();\n  // Track all nodes that could not be removed during the operation\n  const errors = new Set<INode<TNodeMeta, TEdgeMeta>>();\n\n  // Loop through all nodes to remove\n  for (let k = 0, kMax = nodes.length; k < kMax; ++k) {\n    // Get the node to process\n    const node = nodes[k];\n    // See if the id of the node is valid for deletion\n    const toDelete = network.nodeMap.get(node.id);\n\n    // If we deleted the node successfully, then we need to make sure the node\n    // deleted actually is the SAME node object we want to delete. Otherwise,\n    // that's an error where we deleted a node with the same ID, but is NOT an\n    // object truly within the network.\n    if (toDelete) {\n      if (toDelete === node) {\n        network.nodeMap.delete(node.id);\n      } else {\n        errors.add(node);\n        continue;\n      }\n    }\n\n    // If the node is not within the network dataset, we error based on a bad\n    // node identifier specified.\n    else {\n      // If we couldn't delete the node because it wasn't in the network, we\n      // check to see if it was already removed\n      if (!removedNodes.has(node)) {\n        // If it wasn't removed, this means this node just didn't exist at all\n        // in this network, thus is an error\n        errors.add(node);\n      }\n\n      continue;\n    }\n\n    // Clear out the outgoing edges from the node from the network\n    const nodeOut = removeEdge(network, node.out, removedEdges);\n    // Clear out the incoming edges to the node from the network\n    const nodeIn = removeEdge(network, node.in, removedEdges);\n    // Preserve the node's state. It gets modified from the removeEdge operation\n    node.in = Array.from(nodeIn.edges).concat(Array.from(nodeIn.errors || []));\n    node.out = Array.from(nodeOut.edges).concat(\n      Array.from(nodeOut.errors || [])\n    );\n    // Clear out the node from the network\n    network.nodes.splice(network.nodes.indexOf(node), 1);\n    // Flag the node as removed\n    removedNodes.add(node);\n  }\n\n  return {\n    nodes: removedNodes,\n    edges: removedEdges,\n    errors: errors.size > 0 ? errors : null,\n  };\n}\n","import { AnalyzeNode, FlowDirection, IEdge, INode } from \"../types\";\n\nexport interface INeighborsOptions<TNodeMeta, TEdgeMeta> {\n  /** This is a set of nodes to exclude from the result */\n  exclude?: Set<AnalyzeNode<TNodeMeta, TEdgeMeta>>;\n  /**\n   * This specifies which direction of edge to consider for finding the\n   * neighbors. If not specified this defaults to \"BOTH\" for the direction.\n   */\n  flow?: FlowDirection;\n  /**\n   * When node exclusions are provided, this states whether or not you want the\n   * edge to the excluded node included in the results. The property will ONLY\n   * be provided if \"exclude\" is provided as an option.\n   */\n  includeEdgeToExcludedNode?: boolean;\n  /**\n   * When set, the result will contain a property that shows which nodes were\n   * excluded from the operation as a result of the node being in the exclude\n   * set.\n   */\n  includeExcludedNodes?: boolean;\n  /**\n   * A network can have nodes that have circular references (Where the edge's\n   * \"a\" === the edge's \"b\"). The input node for finding it's neighbors by\n   * definition of \"neighbor\" IS an excluded node. HOWEVER, the edge is a\n   * special sort of neighboring edge that may be desired in the output of this\n   * method.\n   *\n   * So, set this property to have the potential circular reference edge\n   * included in the results. Otherwise, for most normal cases, the edge should\n   * be excluded, thus do not set this.\n   */\n  includeEdgeForCircularReference?: boolean;\n  /** This is the target node we want to collect the neighbors for. */\n  node: AnalyzeNode<TNodeMeta, TEdgeMeta>;\n}\n\n/**\n * This method gathers neighboring nodes of an input node. You can optionally\n * exclude nodes from the returned list.\n *\n * If includeEdgeToExcludedNode is set, then when a node is excluded, the result\n * will still contain the edge that went to the node.\n */\nexport function neighbors<TNodeMeta, TEdgeMeta>(\n  options: INeighborsOptions<TNodeMeta, TEdgeMeta>\n) {\n  const {\n    node,\n    exclude,\n    includeEdgeToExcludedNode,\n    includeExcludedNodes,\n    includeEdgeForCircularReference,\n    flow,\n  } = options;\n  const nodes = [];\n  const edges = [];\n  let edgeToExclusion: IEdge<TNodeMeta, TEdgeMeta>[] | undefined;\n\n  if (includeEdgeToExcludedNode) {\n    edgeToExclusion = [];\n  }\n\n  // If flow direction is set, then we can specify which directions to include\n  // If flow is not included or is BOTH then we include both directions.\n  // BOTH === 0 so evaluating flow to falsey is valid here.\n  const includeIn = flow ? flow === FlowDirection.IN : true;\n  const includeOut = flow ? flow === FlowDirection.OUT : true;\n  let excluded: Set<INode<TNodeMeta, TEdgeMeta>> | undefined;\n\n  if (includeExcludedNodes) {\n    excluded = new Set();\n  }\n\n  if (exclude) {\n    // Gather incoming nodes\n    if (includeIn) {\n      for (let i = 0, iMax = node.in.length; i < iMax; ++i) {\n        const edge = node.in[i];\n\n        // Circular reference handling\n        if (edge.a === edge.b) {\n          if (includeEdgeForCircularReference) {\n            edges.push(edge);\n          }\n          continue;\n        }\n\n        if (!exclude.has(edge.a)) {\n          nodes.push(edge.a);\n          edges.push(edge);\n        } else if (edgeToExclusion) {\n          if (excluded) {\n            excluded.add(edge.a);\n          }\n\n          edgeToExclusion.push(edge);\n        }\n      }\n    }\n\n    // Gather outgoing nodes\n    if (includeOut) {\n      for (let i = 0, iMax = node.out.length; i < iMax; ++i) {\n        const edge = node.out[i];\n\n        // Circular reference handling. If we included \"In flows\" then we don't\n        // need to process this again as the in flows will contain the same\n        // circular reference as the outflows\n        if (edge.a === edge.b) {\n          if (includeEdgeForCircularReference && !includeIn) {\n            edges.push(edge);\n          }\n          continue;\n        }\n\n        if (!exclude.has(edge.b)) {\n          nodes.push(edge.b);\n          edges.push(edge);\n        } else if (edgeToExclusion) {\n          if (excluded) {\n            excluded.add(edge.a);\n          }\n\n          edgeToExclusion.push(edge);\n        }\n      }\n    }\n  } else {\n    // Gather incoming nodes\n    if (includeIn) {\n      for (let i = 0, iMax = node.in.length; i < iMax; ++i) {\n        const edge = node.in[i];\n\n        // Circular reference handling\n        if (edge.a === edge.b) {\n          if (includeEdgeForCircularReference) {\n            edges.push(edge);\n          }\n          continue;\n        }\n\n        nodes.push(edge.a);\n        edges.push(edge);\n      }\n    }\n\n    // Gather outgoing nodes\n    if (includeOut) {\n      for (let i = 0, iMax = node.out.length; i < iMax; ++i) {\n        const edge = node.out[i];\n\n        // Circular reference handling. If we included \"In flows\" then we don't\n        // need to process this again as the in flows will contain the same\n        // circular reference as the outflows\n        if (edge.a === edge.b) {\n          if (includeEdgeForCircularReference && !includeIn) {\n            edges.push(edge);\n          }\n          continue;\n        }\n\n        nodes.push(edge.b);\n        edges.push(edge);\n      }\n    }\n  }\n\n  return {\n    nodes,\n    edges,\n    excluded,\n    edgeToExclusion,\n  };\n}\n","import { INode } from \"../types\";\n\n/**\n * Produces a list of nodes and edges shared between the input nodes.\n *\n * The depth provided indicates maximum node jumps the node can be to be considered shared.\n */\nexport async function sharedConnection<TNodeMeta, TEdgeMeta>(\n  _nodes: INode<TNodeMeta, TEdgeMeta>\n) {\n  // TODO\n}\n","import { getEdge } from \"../calculate/get-edge\";\nimport {\n  AnalyzeNode,\n  IEdge,\n  INetworkData,\n  INode,\n  ReversePathMap,\n} from \"../types\";\n\n/**\n * This takes a node and a path mapping and returns a callback for each element\n * along the path starting at the input node and continues until the path start\n * is found.\n *\n * You can provide the network the path is a part of to speed up calculations.\n */\nexport function travelPath<TNodeMeta, TEdgeMeta>(\n  start: AnalyzeNode<TNodeMeta, TEdgeMeta>,\n  path: ReversePathMap<TNodeMeta, TEdgeMeta>,\n  nodeResult: (next: INode<TNodeMeta, TEdgeMeta>, step: number) => void,\n  edgeResult: (next: IEdge<TNodeMeta, TEdgeMeta>, step: number) => void,\n  network?: INetworkData<TNodeMeta, TEdgeMeta>\n) {\n  let step = -1;\n  let next: INode<TNodeMeta, TEdgeMeta> | undefined = start;\n\n  while (next) {\n    nodeResult(next, ++step);\n    const current = next;\n    next = path.get(next);\n\n    // If we have a next element, we get the edge to it first for broadcasting\n    if (next) {\n      const edge = getEdge(next, current, network);\n\n      if (!edge) {\n        console.warn(\n          \"Traveled a path that had two nodes with no connecting edge.\",\n          \"This is an error with the input data structure.\",\n          \"Please make sure all your nodes are a part of a VALID Network Data object\"\n        );\n        return;\n      }\n\n      edgeResult(edge, ++step);\n    }\n  }\n}\n","import { Weights } from \"../types\";\n\n/**\n * Provides the largest weight from a weights value.\n */\nexport function maxWeight(val: Weights) {\n  if (Array.isArray(val)) return Math.max(...val);\n  return val;\n}\n","import { Weights } from \"../types\";\n\n/**\n * Gets the smallest Weight in a given weight measurement\n */\nexport function minWeight(val: Weights) {\n  if (Array.isArray(val)) return Math.min(...val);\n  return val;\n}\n","import { Weights } from \"../types\";\n\n/**\n * This is a normalizing method for accessing a weight at a provided index. If\n * the Weights does not have a value at that index, this returns 0.\n *\n * If the Weights is a single number and not a list, this assumes the weight\n * at any index is the number. If you want to avoid this behavior, then you\n * should make the weight for the node a list of a single number:\n * [0] instead of 0\n */\nexport function weightAtIndex(index: number, weights: Weights) {\n  if (Array.isArray(weights)) return weights[index] || 0;\n  return weights;\n}\n","export * from \"./add-edge\";\nexport * from \"./add-node\";\nexport * from \"./clone-edge\";\nexport * from \"./clone-network\";\nexport * from \"./clone-node\";\nexport * from \"./combine-shared-edges\";\nexport * from \"./convert-network\";\nexport * from \"./empty-network\";\nexport * from \"./make-network\";\nexport * from \"./network-set-operations\";\nexport * from \"./remove-circular-edges\";\nexport * from \"./remove-edge\";\nexport * from \"./remove-node\";\n","import { INetworkData } from \"../types\";\n\n/**\n * Generates a network with nothing in it.\n */\nexport function emptyNetwork<TNodeMeta, TEdgeMeta>(): INetworkData<\n  TNodeMeta,\n  TEdgeMeta\n> {\n  return {\n    nodes: [],\n    nodeMap: new Map(),\n    edges: [],\n    edgeMap: new Map(),\n    atobMap: new Map(),\n  };\n}\n","export * from \"./selection\";\nexport * from \"./calculate\";\nexport * from \"./data\";\nexport * from \"./types\";\nexport * from \"./util\";\n\nimport * as calculate from \"./calculate\";\nimport * as data from \"./data\";\nimport * as selection from \"./selection\";\nimport * as util from \"./util\";\n\n// Make the library easier to navigate by making the major defining sections objects which categorizes the types of\n// functions available.\nexport const Selection = selection;\nexport const Calculate = calculate;\nexport const Data = data;\nexport const Util = util;\n","import { AnalyzeNode, IEdge, INode } from \"../types\";\nimport { makeList } from \"../util\";\n\n/**\n * Retrieves the set of edges from all nodes specified\n */\nexport function allEdges<TNodeMeta, TEdgeMeta>(\n  node: AnalyzeNode<TNodeMeta, TEdgeMeta> | INode<TNodeMeta, TEdgeMeta>[],\n  out?: Set<IEdge<TNodeMeta, TEdgeMeta>>\n) {\n  const nodes = makeList(node);\n  const edges = out || new Set<IEdge<TNodeMeta, TEdgeMeta>>();\n\n  for (let i = 0, iMax = nodes.length; i < iMax; ++i) {\n    const processNode = nodes[i];\n\n    for (let k = 0, kMax = processNode.in.length; k < kMax; ++k) {\n      edges.add(processNode.in[k]);\n    }\n\n    for (let k = 0, kMax = processNode.out.length; k < kMax; ++k) {\n      edges.add(processNode.out[k]);\n    }\n  }\n\n  return edges;\n}\n","/**\n * Shallow compare elements between two lists.\n */\nexport function shallowListCompare<T>(a: T[], b: T[]): boolean {\n  if (a.length !== b.length) return false;\n\n  for (let i = 0, iMax = a.length; i < iMax; ++i) {\n    if (a[i] !== b[i]) return false;\n  }\n\n  return true;\n}\n","import { combineSharedEdges } from \"../data/combine-shared-edges\";\nimport { makeNetwork } from \"../data/make-network\";\nimport { exclusiveRandItems } from \"./random\";\nconst randomSeed = require(\"random-seed\");\n\ninterface IValuedObject {\n  /** A name for the node. May not be unique */\n  name: string;\n  /** A date value on the node */\n  dateMetric: Date;\n  /** A numerical value on the node */\n  numMetric: number;\n  /** A string value on the node */\n  strMetric: string;\n  /** A guaranteed UID identifier */\n  UID?: string | number;\n}\n\nexport interface IRandomNode extends IValuedObject {}\n\nexport interface IRandomNodeWithEdge extends IValuedObject {\n  /** A list of nodes this node connects to */\n  siblings: (string | number)[];\n}\n\nexport interface IRandomEdge extends IValuedObject {\n  /** Guaranteed to point to a Node's UID */\n  UID_A?: string | number;\n  /** Guaranteed to point to a Node's UID */\n  UID_B?: string | number;\n}\n\nfunction randWord(words: string[], rand: (v: number) => number) {\n  return words[rand(words.length)];\n}\n\nfunction randPhrase(\n  words: string[],\n  rand: (v: number) => number,\n  count: number\n) {\n  const out = [];\n\n  for (let i = 0, iMax = count; i < iMax; ++i) {\n    out.push(randWord(words, rand));\n  }\n\n  return out.join(\" \");\n}\n\n/**\n * Generates ramdomized node data. Each node for a given index will always be\n * the same:\n *\n * genNodes(5) === genNodes(5) (deeply equals, not object pointerequals)\n *\n * also\n *\n * genNodes(5) === genNodes(15) for the first 5 nodes\n */\nexport function randomNodes(words: string[], count: number) {\n  let NODE_UID = 0;\n  const rand = randomSeed.create(\"nodes\");\n  const out: IRandomNode[] = [];\n\n  for (let i = 0; i < count; ++i) {\n    out.push({\n      name: randPhrase(words, rand, 3),\n      UID: ++NODE_UID,\n      dateMetric: new Date(),\n      numMetric: rand(1000),\n      strMetric: randWord(words, rand),\n    });\n  }\n\n  return out;\n}\n\n/**\n * This generates random node data that has the connection information in the\n * node data and NOT in a seperate edge data list.\n */\nexport function randomNodesWithEdges(\n  words: string[],\n  count: number,\n  edgesPerNode: number\n) {\n  const rand = randomSeed.create(\"nodes-with-edges\");\n  const nodes: IRandomNodeWithEdge[] = this.randomNodes(words, count);\n\n  for (let i = 0, iMax = nodes.length; i < iMax; ++i) {\n    const node = nodes[i];\n    const items = exclusiveRandItems(rand, nodes, edgesPerNode);\n    node.siblings = items?.map((node) => node.UID || -1) || [];\n  }\n\n  return nodes;\n}\n\n/**\n * Generates randomized edge data. Each node for a given index will always be\n * the same if the input node list is the same:\n *\n * nodes = genNodes(5)\n *\n * genEdges(nodes, 5) === genEdges(nodes, 5) (deeply equals, not object pointer\n * equals)\n *\n * also\n *\n * genEdges(nodes, 5) === genEdges(nodes, 15) for the first 5 edges\n */\nexport function randomEdges(\n  words: string[],\n  nodes: IRandomNode[],\n  count: number\n) {\n  let EDGE_UID = 0;\n  const rand = randomSeed.create(\"edges\");\n  const out: IRandomEdge[] = [];\n\n  for (let i = 0; i < count; ++i) {\n    const pickTwo = exclusiveRandItems(rand, nodes, 2);\n    if (!pickTwo) continue;\n\n    out.push({\n      name: randPhrase(words, rand, 3),\n      UID: ++EDGE_UID,\n      UID_A: pickTwo[0].UID,\n      UID_B: pickTwo[1].UID,\n      dateMetric: new Date(),\n      numMetric: rand(1000),\n      strMetric: randWord(words, rand),\n    });\n  }\n\n  return out;\n}\n\n/**\n * This is a helpful method for generating a randomized network data object\n */\nexport async function randomNetwork<TNodeMeta, TEdgeMeta>(\n  words: string[],\n  nodeCount: number,\n  edgeCount: number,\n  nodeMeta: (nodeRow: IRandomNode) => TNodeMeta,\n  edgeMeta: (edgeRow: IRandomEdge) => TEdgeMeta\n) {\n  const nodes = randomNodes(words, nodeCount);\n  const edges = randomEdges(words, nodes, edgeCount);\n\n  // Make a network from our randomized data\n  const network = await makeNetwork({\n    edgeData: edges,\n    nodeData: nodes,\n\n    nodeId: (nodeRow) => nodeRow.UID || \"\",\n    nodeMeta: nodeMeta,\n    nodeValues: (nodeRow) => nodeRow.numMetric,\n\n    edgeId: (edgeRow) => edgeRow.UID || \"\",\n    edgeMeta: edgeMeta,\n    edgeA: (edgeRow) => edgeRow.UID_A || \"\",\n    edgeB: (edgeRow) => edgeRow.UID_B || \"\",\n    edgeValues: (edgeRow) => ({ ab: edgeRow.numMetric, ba: edgeRow.numMetric }),\n  });\n\n  // Clean up any duplicate edges\n  combineSharedEdges(network, (a, _b) => a);\n\n  return network;\n}\n","/*\n * random-seed\n * https://github.com/skratchdot/random-seed\n *\n * This code was originally written by Steve Gibson and can be found here:\n *\n * https://www.grc.com/otg/uheprng.htm\n *\n * It was slightly modified for use in node, to pass jshint, and a few additional\n * helper functions were added.\n *\n * Copyright (c) 2013 skratchdot\n * Dual Licensed under the MIT license and the original GRC copyright/license\n * included below.\n */\n/*\t============================================================================\n\t\t\t\t\t\t\t\t\tGibson Research Corporation\n\t\t\t\tUHEPRNG - Ultra High Entropy Pseudo-Random Number Generator\n\t============================================================================\n\tLICENSE AND COPYRIGHT:  THIS CODE IS HEREBY RELEASED INTO THE PUBLIC DOMAIN\n\tGibson Research Corporation releases and disclaims ALL RIGHTS AND TITLE IN\n\tTHIS CODE OR ANY DERIVATIVES. Anyone may be freely use it for any purpose.\n\t============================================================================\n\tThis is GRC's cryptographically strong PRNG (pseudo-random number generator)\n\tfor JavaScript. It is driven by 1536 bits of entropy, stored in an array of\n\t48, 32-bit JavaScript variables.  Since many applications of this generator,\n\tincluding ours with the \"Off The Grid\" Latin Square generator, may require\n\tthe deteriministic re-generation of a sequence of PRNs, this PRNG's initial\n\tentropic state can be read and written as a static whole, and incrementally\n\tevolved by pouring new source entropy into the generator's internal state.\n\t----------------------------------------------------------------------------\n\tENDLESS THANKS are due Johannes Baagoe for his careful development of highly\n\trobust JavaScript implementations of JS PRNGs.  This work was based upon his\n\tJavaScript \"Alea\" PRNG which is based upon the extremely robust Multiply-\n\tWith-Carry (MWC) PRNG invented by George Marsaglia. MWC Algorithm References:\n\thttp://www.GRC.com/otg/Marsaglia_PRNGs.pdf\n\thttp://www.GRC.com/otg/Marsaglia_MWC_Generators.pdf\n\t----------------------------------------------------------------------------\n\tThe quality of this algorithm's pseudo-random numbers have been verified by\n\tmultiple independent researchers. It handily passes the fermilab.ch tests as\n\twell as the \"diehard\" and \"dieharder\" test suites.  For individuals wishing\n\tto further verify the quality of this algorithm's pseudo-random numbers, a\n\t256-megabyte file of this algorithm's output may be downloaded from GRC.com,\n\tand a Microsoft Windows scripting host (WSH) version of this algorithm may be\n\tdownloaded and run from the Windows command prompt to generate unique files\n\tof any size:\n\tThe Fermilab \"ENT\" tests: http://fourmilab.ch/random/\n\tThe 256-megabyte sample PRN file at GRC: https://www.GRC.com/otg/uheprng.bin\n\tThe Windows scripting host version: https://www.GRC.com/otg/wsh-uheprng.js\n\t----------------------------------------------------------------------------\n\tQualifying MWC multipliers are: 187884, 686118, 898134, 1104375, 1250205,\n\t1460910 and 1768863. (We use the largest one that's < 2^21)\n\t============================================================================ */\n'use strict';\nvar stringify = require('json-stringify-safe');\n\n/*\t============================================================================\nThis is based upon Johannes Baagoe's carefully designed and efficient hash\nfunction for use with JavaScript.  It has a proven \"avalanche\" effect such\nthat every bit of the input affects every bit of the output 50% of the time,\nwhich is good.\tSee: http://baagoe.com/en/RandomMusings/hash/avalanche.xhtml\n============================================================================\n*/\nvar Mash = function () {\n\tvar n = 0xefc8249d;\n\tvar mash = function (data) {\n\t\tif (data) {\n\t\t\tdata = data.toString();\n\t\t\tfor (var i = 0; i < data.length; i++) {\n\t\t\t\tn += data.charCodeAt(i);\n\t\t\t\tvar h = 0.02519603282416938 * n;\n\t\t\t\tn = h >>> 0;\n\t\t\t\th -= n;\n\t\t\t\th *= n;\n\t\t\t\tn = h >>> 0;\n\t\t\t\th -= n;\n\t\t\t\tn += h * 0x100000000; // 2^32\n\t\t\t}\n\t\t\treturn (n >>> 0) * 2.3283064365386963e-10; // 2^-32\n\t\t} else {\n\t\t\tn = 0xefc8249d;\n\t\t}\n\t};\n\treturn mash;\n};\n\nvar uheprng = function (seed) {\n\treturn (function () {\n\t\tvar o = 48; // set the 'order' number of ENTROPY-holding 32-bit values\n\t\tvar c = 1; // init the 'carry' used by the multiply-with-carry (MWC) algorithm\n\t\tvar p = o; // init the 'phase' (max-1) of the intermediate variable pointer\n\t\tvar s = new Array(o); // declare our intermediate variables array\n\t\tvar i; // general purpose local\n\t\tvar j; // general purpose local\n\t\tvar k = 0; // general purpose local\n\n\t\t// when our \"uheprng\" is initially invoked our PRNG state is initialized from the\n\t\t// browser's own local PRNG. This is okay since although its generator might not\n\t\t// be wonderful, it's useful for establishing large startup entropy for our usage.\n\t\tvar mash = new Mash(); // get a pointer to our high-performance \"Mash\" hash\n\n\t\t// fill the array with initial mash hash values\n\t\tfor (i = 0; i < o; i++) {\n\t\t\ts[i] = mash(Math.random());\n\t\t}\n\n\t\t// this PRIVATE (internal access only) function is the heart of the multiply-with-carry\n\t\t// (MWC) PRNG algorithm. When called it returns a pseudo-random number in the form of a\n\t\t// 32-bit JavaScript fraction (0.0 to <1.0) it is a PRIVATE function used by the default\n\t\t// [0-1] return function, and by the random 'string(n)' function which returns 'n'\n\t\t// characters from 33 to 126.\n\t\tvar rawprng = function () {\n\t\t\tif (++p >= o) {\n\t\t\t\tp = 0;\n\t\t\t}\n\t\t\tvar t = 1768863 * s[p] + c * 2.3283064365386963e-10; // 2^-32\n\t\t\treturn s[p] = t - (c = t | 0);\n\t\t};\n\n\t\t// this EXPORTED function is the default function returned by this library.\n\t\t// The values returned are integers in the range from 0 to range-1. We first\n\t\t// obtain two 32-bit fractions (from rawprng) to synthesize a single high\n\t\t// resolution 53-bit prng (0 to <1), then we multiply this by the caller's\n\t\t// \"range\" param and take the \"floor\" to return a equally probable integer.\n\t\tvar random = function (range) {\n\t\t\treturn Math.floor(range * (rawprng() + (rawprng() * 0x200000 | 0) * 1.1102230246251565e-16)); // 2^-53\n\t\t};\n\n\t\t// this EXPORTED function 'string(n)' returns a pseudo-random string of\n\t\t// 'n' printable characters ranging from chr(33) to chr(126) inclusive.\n\t\trandom.string = function (count) {\n\t\t\tvar i;\n\t\t\tvar s = '';\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\ts += String.fromCharCode(33 + random(94));\n\t\t\t}\n\t\t\treturn s;\n\t\t};\n\n\t\t// this PRIVATE \"hash\" function is used to evolve the generator's internal\n\t\t// entropy state. It is also called by the EXPORTED addEntropy() function\n\t\t// which is used to pour entropy into the PRNG.\n\t\tvar hash = function () {\n\t\t\tvar args = Array.prototype.slice.call(arguments);\n\t\t\tfor (i = 0; i < args.length; i++) {\n\t\t\t\tfor (j = 0; j < o; j++) {\n\t\t\t\t\ts[j] -= mash(args[i]);\n\t\t\t\t\tif (s[j] < 0) {\n\t\t\t\t\t\ts[j] += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// this EXPORTED \"clean string\" function removes leading and trailing spaces and non-printing\n\t\t// control characters, including any embedded carriage-return (CR) and line-feed (LF) characters,\n\t\t// from any string it is handed. this is also used by the 'hashstring' function (below) to help\n\t\t// users always obtain the same EFFECTIVE uheprng seeding key.\n\t\trandom.cleanString = function (inStr) {\n\t\t\tinStr = inStr.replace(/(^\\s*)|(\\s*$)/gi, ''); // remove any/all leading spaces\n\t\t\tinStr = inStr.replace(/[\\x00-\\x1F]/gi, ''); // remove any/all control characters\n\t\t\tinStr = inStr.replace(/\\n /, '\\n'); // remove any/all trailing spaces\n\t\t\treturn inStr; // return the cleaned up result\n\t\t};\n\n\t\t// this EXPORTED \"hash string\" function hashes the provided character string after first removing\n\t\t// any leading or trailing spaces and ignoring any embedded carriage returns (CR) or Line Feeds (LF)\n\t\trandom.hashString = function (inStr) {\n\t\t\tinStr = random.cleanString(inStr);\n\t\t\tmash(inStr); // use the string to evolve the 'mash' state\n\t\t\tfor (i = 0; i < inStr.length; i++) { // scan through the characters in our string\n\t\t\t\tk = inStr.charCodeAt(i); // get the character code at the location\n\t\t\t\tfor (j = 0; j < o; j++) { //\t\"mash\" it into the UHEPRNG state\n\t\t\t\t\ts[j] -= mash(k);\n\t\t\t\t\tif (s[j] < 0) {\n\t\t\t\t\t\ts[j] += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// this EXPORTED function allows you to seed the random generator.\n\t\trandom.seed = function (seed) {\n\t\t\tif (typeof seed === 'undefined' || seed === null) {\n\t\t\t\tseed = Math.random();\n\t\t\t}\n\t\t\tif (typeof seed !== 'string') {\n\t\t\t\tseed = stringify(seed, function (key, value) {\n\t\t\t\t\tif (typeof value === 'function') {\n\t\t\t\t\t\treturn (value).toString();\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t});\n\t\t\t}\n\t\t\trandom.initState();\n\t\t\trandom.hashString(seed);\n\t\t};\n\n\t\t// this handy exported function is used to add entropy to our uheprng at any time\n\t\trandom.addEntropy = function ( /* accept zero or more arguments */ ) {\n\t\t\tvar args = [];\n\t\t\tfor (i = 0; i < arguments.length; i++) {\n\t\t\t\targs.push(arguments[i]);\n\t\t\t}\n\t\t\thash((k++) + (new Date().getTime()) + args.join('') + Math.random());\n\t\t};\n\n\t\t// if we want to provide a deterministic startup context for our PRNG,\n\t\t// but without directly setting the internal state variables, this allows\n\t\t// us to initialize the mash hash and PRNG's internal state before providing\n\t\t// some hashing input\n\t\trandom.initState = function () {\n\t\t\tmash(); // pass a null arg to force mash hash to init\n\t\t\tfor (i = 0; i < o; i++) {\n\t\t\t\ts[i] = mash(' '); // fill the array with initial mash hash values\n\t\t\t}\n\t\t\tc = 1; // init our multiply-with-carry carry\n\t\t\tp = o; // init our phase\n\t\t};\n\n\t\t// we use this (optional) exported function to signal the JavaScript interpreter\n\t\t// that we're finished using the \"Mash\" hash function so that it can free up the\n\t\t// local \"instance variables\" is will have been maintaining.  It's not strictly\n\t\t// necessary, of course, but it's good JavaScript citizenship.\n\t\trandom.done = function () {\n\t\t\tmash = null;\n\t\t};\n\n\t\t// if we called \"uheprng\" with a seed value, then execute random.seed() before returning\n\t\tif (typeof seed !== 'undefined') {\n\t\t\trandom.seed(seed);\n\t\t}\n\n\t\t// Returns a random integer between 0 (inclusive) and range (exclusive)\n\t\trandom.range = function (range) {\n\t\t\treturn random(range);\n\t\t};\n\n\t\t// Returns a random float between 0 (inclusive) and 1 (exclusive)\n\t\trandom.random = function () {\n\t\t\treturn random(Number.MAX_VALUE - 1) / Number.MAX_VALUE;\n\t\t};\n\n\t\t// Returns a random float between min (inclusive) and max (exclusive)\n\t\trandom.floatBetween = function (min, max) {\n\t\t\treturn random.random() * (max - min) + min;\n\t\t};\n\n\t\t// Returns a random integer between min (inclusive) and max (inclusive)\n\t\trandom.intBetween = function (min, max) {\n\t\t\treturn Math.floor(random.random() * (max - min + 1)) + min;\n\t\t};\n\n\t\t// when our main outer \"uheprng\" function is called, after setting up our\n\t\t// initial variables and entropic state, we return an \"instance pointer\"\n\t\t// to the internal anonymous function which can then be used to access\n\t\t// the uheprng's various exported functions.  As with the \".done\" function\n\t\t// above, we should set the returned value to 'null' once we're finished\n\t\t// using any of these functions.\n\t\treturn random;\n\t}());\n};\n\n// Modification for use in node:\nuheprng.create = function (seed) {\n\treturn new uheprng(seed);\n};\nmodule.exports = uheprng;\n","exports = module.exports = stringify\nexports.getSerialize = serializer\n\nfunction stringify(obj, replacer, spaces, cycleReplacer) {\n  return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)\n}\n\nfunction serializer(replacer, cycleReplacer) {\n  var stack = [], keys = []\n\n  if (cycleReplacer == null) cycleReplacer = function(key, value) {\n    if (stack[0] === value) return \"[Circular ~]\"\n    return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\"\n  }\n\n  return function(key, value) {\n    if (stack.length > 0) {\n      var thisPos = stack.indexOf(this)\n      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)\n      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)\n      if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value)\n    }\n    else stack.push(value)\n\n    return replacer == null ? value : replacer.call(this, key, value)\n  }\n}\n","import { addEdge } from \"../data/add-edge\";\nimport { addNode } from \"../data/add-node\";\nimport { removeEdge } from \"../data/remove-edge\";\nimport { removeNode } from \"../data/remove-node\";\nimport { IEdge, IManagedNetworkData, INode, ProcessNetwork } from \"../types\";\n\n/**\n * A listener that can respond to mutations the manager has queued.\n */\nexport interface INetworkDataManagerListener<TNodeMeta, TEdgeMeta> {\n  /** Add edges callback */\n  onAddEdges?(edges: Set<IEdge<TNodeMeta, TEdgeMeta>>): void;\n  /** Add nodes callback */\n  onAddNodes?(nodes: Set<INode<TNodeMeta, TEdgeMeta>>): void;\n  /** Operation errors for edges */\n  onEdgeErrors?(edges: Set<IEdge<TNodeMeta, TEdgeMeta>>): void;\n  /** Operation errors for nodes */\n  onNodeErrors?(nodes: Set<INode<TNodeMeta, TEdgeMeta>>): void;\n  /** Remove edges callback */\n  onRemoveEdges?(edges: Set<IEdge<TNodeMeta, TEdgeMeta>>): void;\n  /** Remove nodes callback */\n  onRemoveNodes?(nodes: Set<INode<TNodeMeta, TEdgeMeta>>): void;\n}\n\nexport interface INetworkDataManager<TNodeMeta, TEdgeMeta> {\n  /**\n   * The data object to monitor by this manager.\n   *\n   * NOTE: only operations carried out by this manager will produce valid\n   * events. Mutating the network data without the manager can not be monitored.\n   */\n  data: ProcessNetwork<TNodeMeta, TEdgeMeta>;\n  /**\n   * If this is provided, the results will only propogate out after a small\n   * delay so that way numerous operations can happen before event broadcasts\n   * occur. If this is not provided, then each change will be broadcasted\n   * immediately.\n   *\n   * Another side effect of including the debounce: if a node or edge is added\n   * and removed several times, the result will only specify the add or remove\n   * once, if that truly changes the state of the network. For example: if a\n   * node is in the network, then removed, then added back again, there will be\n   * no broadcast event for the node itself.\n   */\n  debounce?: number;\n  /** A listener to apply to the manager immediately */\n  listener?: INetworkDataManagerListener<TNodeMeta, TEdgeMeta>;\n}\n\n/**\n * This is a helper manager that provides an event system for handling mutations\n * to your network data object. Essentially, instead of calling data operations\n * on your network directly, use this manager's methods so you can get feedback\n * on the operations that take place via callback.\n */\nexport class NetworkDataManager<TNodeMeta, TEdgeMeta> {\n  private options: INetworkDataManager<TNodeMeta, TEdgeMeta>;\n  private nodeAdds = new Set<INode<TNodeMeta, TEdgeMeta>>();\n  private nodeRemovals = new Set<INode<TNodeMeta, TEdgeMeta>>();\n  private nodeErrors = new Set<INode<TNodeMeta, TEdgeMeta>>();\n  private edgeAdds = new Set<IEdge<TNodeMeta, TEdgeMeta>>();\n  private edgeRemovals = new Set<IEdge<TNodeMeta, TEdgeMeta>>();\n  private edgeErrors = new Set<IEdge<TNodeMeta, TEdgeMeta>>();\n  private timerId: NodeJS.Timeout;\n  private listeners = new Set<INetworkDataManagerListener<TNodeMeta, TEdgeMeta>>();\n\n  /**\n   * This promise is resolved when all changes have been broadcasted. This is\n   * only not resolved when a debounce is specified, otherwise, after each\n   * mutation the manager finishes immediately.\n   */\n  finished = Promise.resolve();\n  /** This is the resolver function to make the finished promise resolve. */\n  private resolve?: Function;\n\n  constructor(options: INetworkDataManager<TNodeMeta, TEdgeMeta>) {\n    this.options = options;\n    if (options.listener) this.addListener(options.listener);\n  }\n\n  /**\n   * Get the data this manager manages, but only offer a readonly look into it.\n   */\n  get data(): IManagedNetworkData<TNodeMeta, TEdgeMeta> {\n    return this.options.data;\n  }\n\n  /**\n   * Adds a listener that will begin to monitor changes to the network data.\n   */\n  addListener(listener: INetworkDataManagerListener<TNodeMeta, TEdgeMeta>) {\n    this.listeners.add(listener);\n  }\n\n  /**\n   * Removes a listener from this manager so it will no longer receive events.\n   */\n  removeListener(listener: INetworkDataManagerListener<TNodeMeta, TEdgeMeta>) {\n    this.listeners.delete(listener);\n  }\n\n  /**\n   * Add a node or several nodes to the network. The node can have edges\n   * established within the node which will be validated for injection into the\n   * network.\n   */\n  addNode(\n    node: INode<TNodeMeta, TEdgeMeta> | INode<TNodeMeta, TEdgeMeta>[]\n  ): ReturnType<typeof addNode> {\n    const { data } = this.options;\n\n    // Modify the network object\n    const result = addNode(data, node);\n\n    // Take the results and populate the broadcast items that are needed\n    result.nodes.forEach(this.doAddNode);\n    result.edges.forEach(this.doAddEdge);\n    result.errors.nodes?.forEach((n) => this.nodeErrors.add(n));\n    result.errors.edges?.forEach((e) => this.edgeErrors.add(e));\n\n    // Broadcast the results. The flush operation accounts for debouncing\n    this.flush();\n\n    return result;\n  }\n\n  /**\n   * Add an edge to the network. The network MUST contain the nodes the edge\n   * specifies or it will be considered an error. Thus, always you ensure you\n   * follow the rule:\n   *\n   * Always add nodes before you add edges.\n   */\n  addEdge(edge: IEdge<TNodeMeta, TEdgeMeta>): ReturnType<typeof addEdge> {\n    const { data } = this.options;\n\n    // Modify the network object\n    const result = addEdge(data, edge);\n\n    // Take the results and populate the broadcast items that are needed\n    result.edges.forEach(this.doAddEdge);\n    result.errors?.forEach((e) => this.edgeErrors.add(e));\n\n    // Broadcast the results. The flush operation accounts for debouncing\n    this.flush();\n\n    return result;\n  }\n\n  /**\n   * Removes a node from the network. This also causes all edges to the\n   * specified node to be removed as well.\n   */\n  removeNode(\n    node: INode<TNodeMeta, TEdgeMeta> | INode<TNodeMeta, TEdgeMeta>[]\n  ): ReturnType<typeof removeNode> {\n    const { data } = this.options;\n\n    // Modify the network object\n    const result = removeNode(data, node);\n\n    // Take the results and populate the broadcast items that are needed\n    result.nodes.forEach(this.doRemoveNode);\n    result.edges.forEach(this.doRemoveEdge);\n    result.errors?.forEach((n) => this.nodeErrors.add(n));\n\n    // Broadcast the results. The flush operation accounts for debouncing\n    this.flush();\n\n    return result;\n  }\n\n  /**\n   * Removes an edge from the network. This will clear the edge from it's\n   * associated nodes.\n   */\n  removeEdge(\n    edge: IEdge<TNodeMeta, TEdgeMeta> | IEdge<TNodeMeta, TEdgeMeta>[]\n  ): ReturnType<typeof removeEdge> {\n    const { data } = this.options;\n\n    // Modify the network object\n    const result = removeEdge(data, edge);\n\n    // Take the results and populate the broadcast items that are needed\n    result.edges.forEach(this.doRemoveEdge);\n    result.errors?.forEach((e) => this.edgeErrors.add(e));\n\n    // Broadcast the results. The flush operation accounts for debouncing\n    this.flush();\n\n    return result;\n  }\n\n  /**\n   * Properly registers a node add and eliminates any add operation that results\n   * in the network containing the same node after a batch of network\n   * mutations.\n   */\n  private doAddNode = (node: INode<TNodeMeta, TEdgeMeta>) => {\n    // If the node has a removal logged, this implies the node once already\n    // existed in the network, which means the node is just being re-added,\n    // which means it's not really an add operation that needs to be broadcast\n    if (this.nodeRemovals.has(node)) {\n      this.nodeRemovals.delete(node);\n    }\n\n    // If no other operation for the node is logged, then this is a legitimate\n    // node add operation.\n    else {\n      this.nodeAdds.add(node);\n    }\n  };\n\n  /**\n   * Properly registers an edge add and eliminates any add operation that\n   * results in the network containing the same edge after a batch of network\n   * mutations.\n   */\n  private doAddEdge = (edge: IEdge<TNodeMeta, TEdgeMeta>) => {\n    // If the edge has a removal logged, this implies the edge once already\n    // existed in the network, which means the edge is just being re-added,\n    // which means it's not really an add operation that needs to be broadcast\n    if (this.edgeRemovals.has(edge)) {\n      this.edgeRemovals.delete(edge);\n    }\n\n    // If no other operation for the node is logged, then this is a legitimate\n    // edge add operation.\n    else {\n      this.edgeAdds.add(edge);\n    }\n  };\n\n  /**\n   * Properly registers a node removal and eliminates any removal operation that\n   * results in the network NOT containing the node after a batch of network\n   * mutations.\n   */\n  private doRemoveNode = (node: INode<TNodeMeta, TEdgeMeta>) => {\n    // If the node has an add logged, then removing this node indicates the node\n    // just will not be added the network in the first place so it does not need\n    // any event broadcast for it for this batch of operations.\n    if (this.nodeAdds.has(node)) {\n      this.nodeAdds.delete(node);\n    }\n\n    // If no other operation for the node is logged, then we simply add the\n    // removal event to be broadcast.\n    else {\n      this.nodeRemovals.add(node);\n    }\n  };\n\n  /**\n   * Properly registers an edge removal and eliminates any removal operation that\n   * results in the network containing the same edge after a batch of network\n   * mutations.\n   */\n  private doRemoveEdge = (edge: IEdge<TNodeMeta, TEdgeMeta>) => {\n    // If the edge has an add logged, then removing this edge indicates the edge\n    // just will not be added the network in the first place so it does not need\n    // any event broadcast for it for this batch of operations.\n    if (this.edgeAdds.has(edge)) {\n      this.edgeAdds.delete(edge);\n    }\n\n    // If no other operation for the edge is logged, then we simply add the\n    // removal event to be broadcast.\n    else {\n      this.edgeRemovals.add(edge);\n    }\n  };\n\n  /**\n   * This flushes out all changes aggregated by this manager and broadcasts the\n   * changes to the event handlers.\n   */\n  flush(force?: boolean) {\n    const {\n      debounce,\n    } = this.options;\n\n    // When debounce is in effect, we make sure we don't broadcast unless the\n    // debouncer resolves.\n    if (debounce && !force) {\n      if (!this.resolve) {\n        this.finished = new Promise<void>((r) => (this.resolve = r));\n      }\n\n      clearTimeout(this.timerId);\n      this.timerId = setTimeout(() => this.flush(true), debounce);\n    } else {\n      // Ensure the timer waiting to fire never does as we're fully flushed now\n      clearTimeout(this.timerId);\n\n      // Broadcast to all listeners of this manager\n      this.listeners.forEach(listener => {\n        const {\n          onRemoveEdges,\n          onRemoveNodes,\n          onEdgeErrors,\n          onNodeErrors,\n          onAddEdges,\n          onAddNodes,\n        } = listener;\n\n        // Broadcast failed element operations\n        if (this.edgeErrors.size > 0) onEdgeErrors?.(this.edgeErrors);\n        this.edgeErrors.clear();\n        if (this.nodeErrors.size > 0) onNodeErrors?.(this.nodeErrors);\n        this.nodeErrors.clear();\n        // Broadcast removals first so responders can first free up resources\n        // before piling on more. These are broadcast in reverse order to the add\n        // nodes first rule, so they can be destructed in an appropriate manner.\n        // It is often required to break all links before an object can be cleanly\n        // discarded.\n        if (this.edgeRemovals.size > 0) onRemoveEdges?.(this.edgeRemovals);\n        this.edgeRemovals.clear();\n        if (this.nodeRemovals.size > 0) onRemoveNodes?.(this.nodeRemovals);\n        this.nodeRemovals.clear();\n        // Now broadcast the add events. Nodes must be added first then edges, so\n        // we will broadcast in that appropriate order\n        if (this.nodeAdds.size > 0) onAddNodes?.(this.nodeAdds);\n        this.nodeAdds.clear();\n        if (this.edgeAdds.size > 0) onAddEdges?.(this.edgeAdds);\n        this.edgeAdds.clear();\n      });\n\n      // Make sure the finished Promise gets resolved.\n      if (this.resolve) {\n        this.resolve();\n        delete this.resolve;\n      }\n    }\n  }\n}\n","import { AnalyzeNetwork } from \"../types\";\n\n/**\n * Produces all nodes that are not connected to anything\n */\nexport function noConnections<TNodeMeta, TEdgeMeta>(\n  network: AnalyzeNetwork<TNodeMeta, TEdgeMeta>\n) {\n  return network.nodes.filter((n) => n.in.length === 0 && n.out.length === 0);\n}\n","import {\n  AnalyzeNodes,\n  FlowDirection,\n  IEdge,\n  INode,\n  ReversePathMap,\n} from \"../types\";\nimport { makeList } from \"../util/make-list\";\nimport { neighbors } from \"./neighbors\";\n\n/**\n * These are the options a result callback can respond with (the result callback\n * is the result property injected in the ISplashOptions). This response can\n * alter how the spread operation proceeds.\n */\nexport interface IRippleResponseOptions {\n  /** If this is set, this causes the spread operation to cease. */\n  stop?: boolean;\n}\n\n/**\n * These are results that can be provided by the splash per each ripple. The\n * contents of results will ALWAYS have nodes and edges. Other metrics may\n * only be available depending on the options provided to the splash.\n */\nexport interface IRippleResult<TNodeMeta, TEdgeMeta> {\n  /**\n   * This provides how deep the current set of nodes are from their nearest\n   * splash source. Depth of 0 IS the splash source node, depth of one is the\n   * neighbors of the splash source, depth of 2 is the neighbor's neighbors, etc\n   * etc.\n   */\n  depth: number;\n  /** All found edges in this execution layer */\n  edges: IEdge<TNodeMeta, TEdgeMeta>[];\n  /** All found nodes in this execution layer */\n  nodes: INode<TNodeMeta, TEdgeMeta>[];\n\n  /**\n   * This is available when includeCollisions is set in the Splash Options.\n   * When a splash is made with multiple points of origin, the ripples emanating\n   * out can encounter a node at the exact same depth. These nodes often need to\n   * be resolved for certain scenarios, and in many scenarios, represent\n   * something very special when examining a network.\n   *\n   * The map is a tracker of a node that has a collision to the nodes\n   * that preceded the collision.\n   */\n  nodeCollisions?: Map<\n    INode<TNodeMeta, TEdgeMeta>,\n    INode<TNodeMeta, TEdgeMeta>[]\n  >;\n\n  /**\n   * This is available when includeCollisions is set in the Splash Options. When\n   * a splash is made with multiple points of origin, the ripples emanating out\n   * can encounter an edge at the exact same depth. These edges often need to be\n   * resolved for certain scenarios, and in many scenarios, represent something\n   * very special when examining a network.\n   *\n   * An edge has the only nodes that could have preceded the collision, so this\n   * collision set is merely a set of the edges discovered to be marked as a\n   * collision.\n   */\n  edgeCollisions?: Set<IEdge<TNodeMeta, TEdgeMeta>>;\n\n  /**\n   * If the splash set the includePath flag, then this is populated with a node's\n   * previously found item during the ripples previous wave. If you keep\n   * recursively searching for a parent, you will eventually get to the\n   * originating node. The originating node will then have no parent and return\n   * undefined if searched for in this path.\n   *\n   * NOTE: You MUST have includeCollisions if you want to resolve equi-distant\n   * paths to a node from multiple splash sources. This will only store the path\n   * for the node from a source for a ripple that FIRST encounters the node. The\n   * collision information allows you to analyze all nodes one step before the\n   * collision happened so you can trace all directions the collision originated\n   * from.\n   */\n  path?: ReversePathMap<TNodeMeta, TEdgeMeta>;\n\n  /**\n   * If the splash options specified includeSource, this will be populated with\n   * a map that links a node to the nearest splash node.\n   *\n   * It should be noted: a node may be equal distant from two splash nodes, if\n   * this is a concern for the operation you are carrying out, then you should\n   * includeCollisions in your splash options, which will allow you to resolve\n   * those scenarios.\n   */\n  source?: Map<INode<TNodeMeta, TEdgeMeta>, INode<TNodeMeta, TEdgeMeta>>;\n}\n\n/**\n * The handler type for handling results found from ripples.\n */\nexport type IRippleResultHandler<TNodeMeta, TEdgeMeta> = (\n  data: IRippleResult<TNodeMeta, TEdgeMeta>\n) => Promise<IRippleResponseOptions | null | undefined | void>;\n\n/**\n * This describes how a splash operation prioritizes it's operations as it's\n * ripples interact with other ripples taking place at the same time.\n */\nexport enum RipplePriority {\n  /** Will execute on nodes that have been visited by other ripples */\n  BLENDS,\n  /**\n   * Will execute on nodes that have been visited by previous ripples and\n   * prevent those ripples from executing on any node this has executed on.\n   */\n  OVERRIDES,\n  /**\n   * Will not execute on a visited node and will stop rippling from that point,\n   * but will continue on nodes that have not encountered other ripples.\n   */\n  TERMINATES,\n  /**\n   * Once a visited node is discovered, all ripples started by the splash quits.\n   */\n  COMPLETELY_TERMINATES,\n  /**\n   * When this hits a visited node of another ripple, it will immediately cancel\n   * the ripples that have visited that node.\n   */\n  TERMINATES_OTHERS,\n}\n\n/**\n * These are the options you can inject for creating a splash.\n */\nexport interface ISplashOptions<TNodeMeta, TEdgeMeta> {\n  /**\n   * Set this to remove edges that connect two nodes that have the same depth\n   * level from the splash location.\n   */\n  excludeSameDepthEdges?: boolean;\n  /**\n   * When this is set, if you specify multiple startNodes, you will get ripples\n   * that encounter nodes at the exact same depth. We call these points\n   * collisions and will be provided in the results of the splash callback.\n   *\n   * Additionally, it is possible a collision will happen at an edge instead of\n   * a node. This is the same principle as a node collision except this is a\n   * special case where the ripples will have crossed at the same time at the\n   * edge thus not triggering a collision at the edge's two end nodes.\n   *\n   * Though implied, I will explicitly state here: COLLISIONS ONLY HAPPEN WITHIN\n   * THE SAME SPLASH. Multiple splashes will NOT cause collisions, only a splash\n   * with MULTIPLE start points will cause collisions.\n   *\n   * These are special case nodes and represent points of VERY HIGH interest\n   * when examining a network. These collisions, combined with pathing can give\n   * shortest path results and many other interesting insights.\n   */\n  includeCollisions?: boolean;\n  /**\n   * When this is set, the result will provide a map of a node to the nearest\n   * splash point that caused the node to get aggregated.\n   */\n  includeSource?: boolean;\n  /**\n   * If this is set to true, then an additional result property will be created\n   * that will provide a path that returns to the originating node.\n   */\n  includePath?: boolean;\n  /**\n   * This specifies how ripples should travel from node to node. You can limit\n   * the outward propagation to travel only via outgoing or incoming edges.\n   * By default it propagates via any edge connection.\n   */\n  flow?: FlowDirection;\n  /**\n   * Specifies how a spread operation will interact with existing spread\n   * operations. By default, the ripple will RipplePriority.BLEND with other\n   * ripples.\n   */\n  priority?: RipplePriority;\n  /**\n   * When set to true, this causes this spread operation to wait for all other\n   * layer executions to complete a cycle before this spread operation\n   * continues.\n   */\n  waitsForLayers?: boolean;\n  /**\n   * When specified, this limits how deep into the network the spread will go\n   * from the input start nodes. Depth is an integer where depth 0 is the start\n   * node and each subsequent neighbor node is 1 depth farther.\n   */\n  maxDepth?: number;\n  /**\n   * When specified, this limits how many nodes can be aggregated at once while\n   * spreading out.\n   */\n  maxNodesPerExecution?: number;\n  /**\n   * These are the nodes you essentially throw a rock at to make a splash. The\n   * ripples made will start at these nodes and radiate away from those nodes,\n   * collecting all nodes and edges it encounters along the way in the fashion\n   * the configuration specifies.\n   */\n  startNodes: AnalyzeNodes<TNodeMeta, TEdgeMeta>;\n}\n\n/**\n * This stores current state of the ripples created from a splash.\n *\n * TODO OPTIMIZATION CONSIDERATIONS:\n * - A thought occurred to me that as ripples propagate out, there is no need\n *   to store ALL visited nodes in certain conditions.\n */\nclass Ripples<TNodeMeta, TEdgeMeta> {\n  /** This indicates if the ripple is still propagating or not */\n  isAlive: boolean = true;\n  /**\n   * For some operations we need to track a node that has been scooped up in a\n   * wave back to the source node the wave started from.\n   */\n  private nodeToSource?: Map<\n    INode<TNodeMeta, TEdgeMeta>,\n    INode<TNodeMeta, TEdgeMeta>\n  >;\n  /** These are the options that created these ripples */\n  private options: ISplashOptions<TNodeMeta, TEdgeMeta>;\n  /**\n   * When this is set, these ripples will keep a log of node to parent node\n   * which builds a path back to the epicenter of where the splash for the\n   * ripple started.\n   */\n  private path?: Map<INode<TNodeMeta, TEdgeMeta>, INode<TNodeMeta, TEdgeMeta>>;\n  /** This is our handler that results are passed off to */\n  private sendResult: IRippleResultHandler<TNodeMeta, TEdgeMeta>;\n  /**\n   * This is the node visitation set that specifies which nodes have been\n   * visited, which helps aid in the next wave to pick the next nodes without\n   * picking already processed nodes.\n   */\n  private visitedNodes = new Set<INode<TNodeMeta, TEdgeMeta>>();\n  /**\n   * This is the edge visitation set that specifies which edges have been\n   * visited, which helps aid in the next wave to pick the next edges without\n   * picking already processed edges.\n   */\n  private visitedEdges = new Set<IEdge<TNodeMeta, TEdgeMeta>>();\n  /**\n   * This is the list of nodes that will next be processed as the ripples\n   * emanate out.\n   */\n  private waveFront: INode<TNodeMeta, TEdgeMeta>[] = [];\n  /**\n   * This tracks how deep the wave front has progressed (how many times wave)\n   * has been called.\n   */\n  private waveFrontDepth: number = 0;\n\n  /**\n   * This promise resolves when the ripples have resolved\n   */\n  finished: Promise<void>;\n  /** Resolver for the finished promise */\n  private resolveFinish: Function;\n\n  constructor(\n    options: ISplashOptions<TNodeMeta, TEdgeMeta>,\n    sendResult: IRippleResultHandler<TNodeMeta, TEdgeMeta>\n  ) {\n    this.options = options;\n    this.sendResult = sendResult;\n  }\n\n  /**\n   * Stops the ripples from continuing any farther, kills all ripples and cleans\n   * up any memory no longer needed after the stop has occurred.\n   */\n  private stop() {\n    this.isAlive = false;\n    this.visitedEdges.clear();\n    this.visitedNodes.clear();\n    this.resolveFinish();\n  }\n\n  /**\n   * This examines a response generated from broadcasting a result and applies\n   * the response to the state of the ripple.\n   *\n   * This returns the current alive state of the process.\n   */\n  private processResultResponse(\n    response?: IRippleResponseOptions | null | void\n  ): boolean {\n    if (!response) return this.isAlive;\n\n    // The response can provide a stop signal to cause the ripple to abruptly\n    // end.\n    if (response.stop) {\n      this.stop();\n    }\n\n    return this.isAlive;\n  }\n\n  /**\n   * Start up the ripples and perform first wave actions as needed\n   */\n  async init(): Promise<boolean> {\n    if (this.finished) return this.isAlive;\n    // Make our new promise that will resolve when this ripple sequence has\n    // completed entirely.\n    this.finished = new Promise<void>((r) => (this.resolveFinish = r));\n\n    const {\n      startNodes,\n      includeCollisions,\n      includeSource,\n      includePath,\n    } = this.options;\n\n    // We check our start points and strip out any duplicates\n    const checkStartPoints = new Set<INode<TNodeMeta, TEdgeMeta>>();\n    const start = makeList(startNodes);\n\n    for (let i = 0, iMax = start.length; i < iMax; ++i) {\n      const node = start[i];\n\n      if (checkStartPoints.has(node)) {\n        console.warn(\n          \"Duplicate start points detected for a Splash. Duplicates will be stripped out.\"\n        );\n        continue;\n      }\n\n      this.visitedNodes.add(node);\n      this.waveFront.push(node);\n    }\n\n    // In certain cases we need to track a node that has been gathered by a wave\n    // front back to the Ripples source node.\n    if (includeCollisions || includeSource) {\n      this.nodeToSource = new Map<\n        INode<TNodeMeta, TEdgeMeta>,\n        INode<TNodeMeta, TEdgeMeta>\n      >();\n\n      // Each of these nodes IS the node source, so we flag them as such\n      for (let i = 0, iMax = this.waveFront.length; i < iMax; ++i) {\n        const node = this.waveFront[i];\n        this.nodeToSource.set(node, node);\n      }\n    }\n\n    // If the splash options specifies that pathing should be tracked for the\n    // ripple as it propagates, then we generate the path object to store the\n    // parent relationship to the nodes generated.\n    // We also need the path for collision calculations so we can keep track of\n    // previous node elements before the collision happens\n    if (includePath || includeCollisions) {\n      this.path = new Map();\n    }\n\n    // On initialization we must immediately broadcast the first nodes as the\n    // beginning of our ripple.\n    const response = await this.sendResult({\n      depth: this.waveFrontDepth,\n      nodes: this.waveFront,\n      nodeCollisions: this.options.includeCollisions ? new Map() : undefined,\n      edges: [],\n      edgeCollisions: this.options.includeCollisions ? new Set() : undefined,\n      path: this.path,\n      source: this.nodeToSource,\n    });\n\n    // Process our result\n    this.processResultResponse(response);\n\n    return this.isAlive;\n  }\n\n  /**\n   * This executes the next wave for the ripple. When this returns false, the\n   * ripple has completed and won't propagate no matter how many times you call\n   * it.\n   */\n  async wave(): Promise<boolean> {\n    // Dead ripples don't wave.\n    if (\n      !this.isAlive ||\n      this.waveFrontDepth > (this.options.maxDepth || Number.MAX_SAFE_INTEGER)\n    ) {\n      return false;\n    }\n\n    // This is the next depth layer of wave\n    this.waveFrontDepth++;\n\n    // Check wave depth after incrementing\n    if (\n      this.waveFrontDepth > (this.options.maxDepth || Number.MAX_SAFE_INTEGER)\n    ) {\n      this.stop();\n      return false;\n    }\n\n    // This will aggregate all of the next nodes for the next wave front once\n    // this wave front has been processed and cleaned out.\n    const nextWaveFront = new Set<INode<TNodeMeta, TEdgeMeta>>();\n    // This will aggregate the edges to include in the result\n    const edges = new Set<IEdge<TNodeMeta, TEdgeMeta>>();\n\n    // Get the configuration of the splash for handling our wave behavior\n    const {\n      includeCollisions,\n      excludeSameDepthEdges,\n      flow,\n      includePath,\n    } = this.options;\n\n    // If we specify the need for collisions, then we create our node\n    // collision output object\n    let nodeCollisions: IRippleResult<TNodeMeta, TEdgeMeta>[\"nodeCollisions\"];\n    if (includeCollisions) {\n      nodeCollisions = new Map();\n    }\n\n    // If we specify the need for collisions, then we create our edge\n    // collision output object\n    let checkForEdgeCollisions: Set<IEdge<TNodeMeta, TEdgeMeta>> | undefined;\n    let edgeCollisions: IRippleResult<TNodeMeta, TEdgeMeta>[\"edgeCollisions\"];\n    if (includeCollisions) {\n      edgeCollisions = new Set();\n      checkForEdgeCollisions = new Set();\n    }\n\n    // Process all nodes in the current wave front to find their next neighbors\n    for (let i = 0, iMax = this.waveFront.length; i < iMax; ++i) {\n      const node = this.waveFront[i];\n      let nodeSource: INode<TNodeMeta, TEdgeMeta> | undefined;\n\n      // This is technically an error, but we will just continue and see what\n      // happens\n      if (!node) {\n        console.warn(`\n          Error: A wave front contained an undefined node which should not be possible.\n          This is either an error in the ripple select code base or the input network\n          has an invalid configuration.\n        `);\n        continue;\n      }\n\n      // If we're tracking a node back to it's source, then we must get this\n      // node's source so it can be passed along to it's newfound neighbors.\n      if (this.nodeToSource) {\n        nodeSource = this.nodeToSource.get(node);\n      }\n\n      // Gather the neighbors of this node to add to our next wave front\n      const siblings = neighbors({\n        node,\n        exclude: this.visitedNodes,\n        includeEdgeToExcludedNode: true,\n        includeExcludedNodes: includeCollisions,\n        includeEdgeForCircularReference: !excludeSameDepthEdges,\n        flow,\n      });\n\n      // Add those neighbors into our next processing queue\n      for (let i = 0, iMax = siblings.nodes.length; i < iMax; ++i) {\n        const child = siblings.nodes[i];\n        nextWaveFront.add(child);\n        this.visitedNodes.add(child);\n\n        // If we are tracking back to the node source, then we need to register\n        // this neighboring node found with it's parent's node's node source so\n        // we can back track this node to the ripple epicenter that generated\n        // this part of the wave front.\n        if (this.nodeToSource && nodeSource) {\n          this.nodeToSource.set(child, nodeSource);\n        }\n\n        // If we need to track the path we took to reach this node, we store the\n        // processed node as the parent and the neighbor node as the key\n        // reference to find the parent.\n        if (this.path) {\n          this.path.set(child, node);\n        }\n      }\n\n      // If we include collisions, then we need to analyze our neighbor\n      // calculation's excluded nodes against our current wavefront. If the\n      // node was excluded as a result of the current wave front, then we know\n      // the node was a collision from ripples created in the same splash.\n      if (\n        nodeSource &&\n        nodeCollisions &&\n        this.path &&\n        this.nodeToSource &&\n        siblings.excluded\n      ) {\n        // Store properties in this context that are not undefined so we know\n        // they are valid for the duration of the loop through the exclusions\n        // set\n        const collisions = nodeCollisions;\n        const currentSource = nodeSource;\n        const nodeToSource = this.nodeToSource;\n        const path = this.path;\n\n        siblings.excluded.forEach((excludedNode) => {\n          // If the nextWaveFront has this exlcuded node, then we have\n          // detected a collision\n          if (nextWaveFront.has(excludedNode)) {\n            let collisionSources = collisions.get(excludedNode);\n\n            // If the node already has a collision, then we just need to add\n            // this node's source to the collisions that have happened\n            if (collisionSources) {\n              collisionSources.push(node);\n            }\n\n            // Otherwise, this collision is new and neither node has been\n            // entered as a collision. So we must add this node source AND the\n            // collided node's currently registered node source to make our\n            // new collision entry\n            else {\n              // Get the node source that first discovered this node\n              const collidedNodeSource = nodeToSource.get(excludedNode);\n              // Get the node that preceded this collided node\n              const collidedEntryNode = path.get(excludedNode);\n\n              if (!collidedEntryNode) {\n                console.warn(\n                  \"A new Node Collision was detected, but an exisiting source node was NOT found\",\n                  \"for the node collided with. This could indicate a malformed data structure\",\n                  \"or a bug was found in this selection algorithm.\"\n                );\n                return;\n              }\n\n              if (!collidedNodeSource) {\n                console.warn(\n                  \"A new Node Collision was detected, but an exisiting source node was NOT found\",\n                  \"for the node collided with. This could indicate a malformed data structure\",\n                  \"or a bug was found in this selection algorithm.\"\n                );\n                return;\n              }\n\n              // Collisions can't happen from the same source colliding\n              if (currentSource !== collidedNodeSource) {\n                collisionSources = [node, collidedEntryNode];\n                collisions.set(excludedNode, collisionSources);\n              }\n            }\n          }\n        });\n      }\n\n      // These are the sibling's edges included in the results\n      for (let k = 0, kMax = siblings.edges.length; k < kMax; ++k) {\n        const edge = siblings.edges[k];\n\n        if (!this.visitedEdges.has(edge)) {\n          edges.add(edge);\n          this.visitedEdges.add(edge);\n        }\n      }\n\n      // If the same depth edging is included, then we will add in those to our\n      // output, also use these special case edges to detect collisions between\n      // ripples.\n      if (siblings.edgeToExclusion) {\n        // If we are checking for collisions, we perform a few additional checks\n        // when processing our edge exclusions\n        if (checkForEdgeCollisions && edgeCollisions && this.nodeToSource) {\n          for (\n            let k = 0, kMax = siblings.edgeToExclusion.length;\n            k < kMax;\n            ++k\n          ) {\n            const edge = siblings.edgeToExclusion[k];\n\n            if (!excludeSameDepthEdges) {\n              if (!this.visitedEdges.has(edge)) {\n                edges.add(edge);\n                this.visitedEdges.add(edge);\n              }\n            }\n\n            // If our check for collision has an existing edge, then this is a\n            // collision at this edge. The reason for this is slightly\n            // complicated and requires some step by step considerations:\n            // - A wavefront that is close enough to itself, where two nodes in\n            //   the same front are separated by a mere edge, will attempt to\n            //   gather each other in the neighbor selection, but both nodes\n            //   will consider each other as excluded, thus both nodes will add\n            //   the edge to the edge for exclusions list.\n            // - A single wavefront being processed will ONLY have this double\n            //   edge addition because every node in a wave front is unique. It\n            //   is impossible with a unique node set to gather the same edge\n            //   due to exclusion UNLESS the nodes are neighbors AND in the same\n            //   wave.\n            // - These assumptions have one additional check of making sure the\n            //   two nodes come from different sources.\n            if (checkForEdgeCollisions.has(edge) && !edgeCollisions.has(edge)) {\n              const nodeSourceA = this.nodeToSource.get(edge.a);\n              const nodeSourceB = this.nodeToSource.get(edge.b);\n\n              if (!nodeSourceA || !nodeSourceB) {\n                continue;\n              }\n\n              if (nodeSourceA !== nodeSourceB) {\n                edgeCollisions.add(edge);\n              }\n            } else {\n              checkForEdgeCollisions.add(edge);\n            }\n          }\n        }\n\n        // If no collisions needed, then simply add the same depth edges if needed\n        else if (!excludeSameDepthEdges) {\n          for (\n            let k = 0, kMax = siblings.edgeToExclusion.length;\n            k < kMax;\n            ++k\n          ) {\n            const edge = siblings.edgeToExclusion[k];\n\n            if (!this.visitedEdges.has(edge)) {\n              edges.add(edge);\n              this.visitedEdges.add(edge);\n            }\n          }\n        }\n      }\n    }\n\n    // Make our newly discovered wavefront the current wave front of the ripple\n    this.waveFront = makeList(nextWaveFront);\n    // Convert our output edge set to a list\n    const outEdges = makeList(edges);\n\n    // Hand the results to the caller and wait for a response. Execution halts\n    // until the caller responds.\n    const response = await this.sendResult({\n      depth: this.waveFrontDepth,\n      edges: outEdges,\n      nodes: this.waveFront,\n      path: includePath ? this.path : undefined,\n      source: this.nodeToSource,\n      nodeCollisions,\n      edgeCollisions,\n    });\n\n    // Analyze the response for feedback on what to do next\n    this.processResultResponse(response);\n\n    // We can now fire up the next layer of execution if needed\n    if (this.waveFront.length > 0) this.wave();\n    // If there is no longer a wave front, then we fully stop the ripple\n    else {\n      this.stop();\n    }\n\n    return this.isAlive;\n  }\n}\n\n/**\n * Think of your nodes and edges like a pool of water. If you throw a rock in\n * it, it will create a splash. From that splash you will see ripples emanate\n * out. There are probably more technical definitions of this style of\n * traversing a network graph; however, this analogy is the easiest to\n * conceptualize and thus is how i'm encapsulating the concept.\n *\n * With this selection you create a 'splash' point (A node or a list of\n * nodes). From those points, using the edges as guides, nodes will be collected\n * and continue to be collected until the criteria for the splash is met or\n * until all nodes have been processed.\n *\n * This manages overlapping ripples. You can create multiple 'splashes' whose\n * ripples interact with each other in interesting ways. Each splash can have\n * multiple splash origins thus creating multiple ripples per splash.\n *\n * The interactions can get complex as they all emanate out, so this manager\n * helps simplify those interactions.\n */\nexport class RippleSelect {\n  rippleLayers: Ripples<any, any>[] = [];\n  finished?: Promise<void>;\n\n  /**\n   * The rippleResult callback provides the results the ripple discovers as it\n   * finds each new wave of nodes and edges.\n   *\n   * The next wave of the ripple will NOT execute until a response is returned.\n   * This provides a means to control how quickly the spread operation occurs\n   * and how much resources the ripple will control at any given moment.\n   *\n   * Example that makes each ripple wave execute after every frame:\n   *\n   * ```\n   * async (data) => {\n   *   await onFrame(); return {};\n   * }\n   * ```\n   *\n   * When the results are provided, you have an opportunity to control several\n   * aspects of the ripple in it's current state, such as, cancel the\n   * operation, delay the next wave, and much more as new features are added.\n   */\n  splash<TNodeMeta, TEdgeMeta>(\n    options: ISplashOptions<TNodeMeta, TEdgeMeta>,\n    rippleResults: IRippleResultHandler<TNodeMeta, TEdgeMeta>\n  ) {\n    const ripples = new Ripples(options, rippleResults);\n    ripples.init();\n    ripples.wave();\n\n    return ripples.finished;\n  }\n}\n","import { getEdge } from \"../calculate/get-edge\";\nimport {\n  AnalyzeEdge,\n  AnalyzeNode,\n  AnalyzeNodeList,\n  IEdge,\n  INode,\n  isEdge,\n  isNode,\n  ReversePathMap,\n} from \"../types\";\nimport { travelPath } from \"./travel-path\";\n\n/**\n * It's a special case when a collision occurs and you want to travel along it's\n * path. Essentially, when a collision happens, there are multiple paths that\n * can be taken as there are multiple sources that reached the node at the same\n * time in a ripple select. This will travel all of the paths back to the\n * sources and include the start node or edge.\n *\n * The collision node will be included for each path traversed (when step === 0)\n * and each path will increment the path feedback int he callbacks.\n */\nexport function travelCollisionPath<TNodeMeta, TEdgeMeta>(\n  collision:\n    | AnalyzeNode<TNodeMeta, TEdgeMeta>\n    | AnalyzeEdge<TNodeMeta, TEdgeMeta>,\n  sources: AnalyzeNodeList<TNodeMeta, TEdgeMeta>,\n  path: ReversePathMap<TNodeMeta, TEdgeMeta>,\n  nodeResult: (\n    node: INode<TNodeMeta, TEdgeMeta>,\n    step: number,\n    path: number\n  ) => void,\n  edgeResult: (\n    edge: IEdge<TNodeMeta, TEdgeMeta>,\n    step: number,\n    path: number\n  ) => void\n) {\n  // If our collision is an edge, then our sources are naturally the ends of the\n  // edge, so we disregard any sources provided\n  if (isEdge(collision)) {\n    sources = [collision.a, collision.b];\n  }\n\n  // Loop through each source and start with the collision node and the edge to\n  // that node, then perform a normal traversal\n  for (let i = 0, iMax = sources.length; i < iMax; ++i) {\n    let step = -1;\n    const source = sources[i];\n\n    if (isNode(collision)) {\n      nodeResult(collision, ++step, i);\n      const edge = getEdge(source, collision);\n\n      if (!edge) {\n        console.warn(\n          \"There was no edge from the source node to the rest of the path\",\n          \"This indicates malformed data, thus it should be ensured that the data\",\n          \"being queried should come from a VALID Network Data object.\"\n        );\n        continue;\n      }\n\n      edgeResult(edge, ++step, i);\n    } else {\n      edgeResult(collision, ++step, i);\n    }\n\n    // We now traverse the remainder of the path from the node beyond the\n    // collision using our normal path traversal system.\n    travelPath(\n      source,\n      path,\n      (node) => nodeResult(node, ++step, i),\n      (edge) => edgeResult(edge, ++step, i)\n    );\n  }\n}\n","import { IdentifiableById } from \"deltav\";\nimport { AnalyzeEdge, AnalyzeNetwork, AnalyzeNode, Weights } from \"../types\";\n\n/**\n * This compares two lists of items that have an ID property\n */\nexport function compareIdentifiers(\n  a: IdentifiableById[],\n  b: IdentifiableById[]\n) {\n  if (a.length !== b.length) return false;\n\n  for (let i = 0, iMax = a.length; i < iMax; ++i) {\n    if (a[i].id !== b[i].id) return false;\n  }\n\n  return true;\n}\n\n/**\n * This compares two weight values with each other\n */\nexport function compareWeights(weightA: Weights, weightB: Weights) {\n  const isList = Array.isArray(weightA);\n  if (isList !== Array.isArray(weightB)) return false;\n  if (isList) {\n    const A = weightA as number[];\n    const B = weightB as number[];\n    if (A.length !== B.length) return false;\n\n    for (let i = 0, iMax = A.length; i < iMax; ++i) {\n      if (A[i] !== B[i]) return false;\n    }\n  } else {\n    return weightA === weightB;\n  }\n\n  return true;\n}\n\n/**\n * This compares two nodes to see if they have the same properties. Edge references are compared by id.\n */\nexport function compareNodes<TNodeMeta, TEdgeMeta>(\n  nodeA: AnalyzeNode<TNodeMeta, TEdgeMeta>,\n  nodeB: AnalyzeNode<TNodeMeta, TEdgeMeta>\n) {\n  return (\n    nodeA.id === nodeB.id &&\n    nodeA.meta === nodeB.meta &&\n    compareIdentifiers(nodeA.in, nodeB.in) &&\n    compareIdentifiers(nodeA.out, nodeB.out) &&\n    compareWeights(nodeA.value, nodeB.value)\n  );\n}\n\n/**\n * This compares two edges to see if they have the same properties. Node references are compared by id.\n */\nexport function compareEdges<TNodeMeta, TEdgeMeta>(\n  edgeA: AnalyzeEdge<TNodeMeta, TEdgeMeta>,\n  edgeB: AnalyzeEdge<TNodeMeta, TEdgeMeta>\n) {\n  return (\n    edgeA.a.id === edgeB.a.id &&\n    edgeA.b.id === edgeB.b.id &&\n    edgeA.id === edgeB.id &&\n    edgeA.meta === edgeB.meta &&\n    compareWeights(edgeA.atob, edgeB.atob) &&\n    compareWeights(edgeA.btoa, edgeB.btoa)\n  );\n}\n\n/**\n * This compares two networks equivalence.\n */\nexport function compareNetworks<TNodeMeta, TEdgeMeta>(\n  networkA: AnalyzeNetwork<TNodeMeta, TEdgeMeta>,\n  networkB: AnalyzeNetwork<TNodeMeta, TEdgeMeta>\n) {\n  // Check for node equivalence\n  if (networkA.nodes.length !== networkB.nodes.length) return false;\n\n  for (let i = 0, iMax = networkA.nodes.length; i < iMax; ++i) {\n    const nodeA = networkA.nodes[i];\n    const nodeB = networkA.nodes[i];\n\n    if (!compareNodes(nodeA, nodeB)) {\n      return false;\n    }\n  }\n\n  // Check for edge equivalence\n  if (networkA.edges.length !== networkB.edges.length) return false;\n\n  for (let i = 0, iMax = networkA.edges.length; i < iMax; ++i) {\n    const edgeA = networkA.edges[i];\n    const edgeB = networkA.edges[i];\n\n    if (!compareEdges(edgeA, edgeB)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import { AnalyzeNode } from \"../types\";\n\n/**\n * Examines a node and determines if it has a circular edge reference to itself\n * or not.\n */\nexport function hasCircularEdge<TNodeMeta, TEdgeMeta>(\n  node: AnalyzeNode<TNodeMeta, TEdgeMeta>\n) {\n  // Get the shortest list to loop through. Both in AND out listings will have\n  // the same circular references if any exists\n  const edgeList = node.in.length > node.out.length ? node.out : node.in;\n  // If either list is empty, it's impossible to have a circular reference.\n  if (node.in.length === 0 || node.out.length === 0) return false;\n\n  // Check each edge in the shortest list for equivalent end points\n  for (let i = 0, iMax = edgeList.length; i < iMax; ++i) {\n    const edge = edgeList[i];\n    if (edge.a === edge.b) return true;\n  }\n\n  // No circular references detected if we reached this point.\n  return false;\n}\n","import { AnalyzeNetwork, AnalyzeNodes, INode } from \"../types\";\nimport { makeList } from \"../util/make-list\";\n\n/**\n * This method checks to see if one or more nodes are within the specified network. If any node in the list is not\n * in the network, this returns false. This performs the examination by node id.\n */\nexport function hasNode<TNodeMeta, TEdgeMeta>(\n  network: AnalyzeNetwork<TNodeMeta, TEdgeMeta>,\n  nodes: AnalyzeNodes<TNodeMeta, TEdgeMeta> | INode<TNodeMeta, TEdgeMeta>[]\n) {\n  // Ensure we are working with a list\n  nodes = makeList(nodes);\n\n  // Check each item in the list for existance within the network specified\n  for (let i = 0, iMax = nodes.length; i < iMax; ++i) {\n    const node = nodes[i];\n    if (!network.nodeMap.has(node.id)) return false;\n  }\n\n  // If we reach here, then all nodes are in network\n  return true;\n}\n","import { AnalyzeNetwork } from \"../types\";\nimport { maxWeight } from \"./max-weight\";\nimport { minWeight } from \"./min-weight\";\nimport { weightAtIndex } from \"./weight-at-index\";\n\n/**\n * This calculates the range of the weights on the nodes in a given data network\n *\n * @param network The network data who's nodes we want to examine\n * @param weightIndex If this is provided, this will do the weight comparison\n *                    at the given index in the list of weights for the node.\n *                    If not provided, this will look across ALL weights in\n *                    every node to find the min and max.\n */\nexport function nodeWeightRange<TNodeMeta, TEdgeMeta>(\n  network: AnalyzeNetwork<TNodeMeta, TEdgeMeta>,\n  weightIndex?: number\n): [number, number] {\n  let nodeMin = Number.MAX_SAFE_INTEGER;\n  let nodeMax = Number.MIN_SAFE_INTEGER;\n\n  if (weightIndex === void 0) {\n    for (let i = 0, iMax = network.nodes.length; i < iMax; ++i) {\n      const node = network.nodes[i];\n      nodeMin = Math.min(nodeMin, minWeight(node.value));\n      nodeMax = Math.max(nodeMax, maxWeight(node.value));\n    }\n  } else {\n    for (let i = 0, iMax = network.nodes.length; i < iMax; ++i) {\n      const node = network.nodes[i];\n      nodeMin = Math.min(nodeMin, weightAtIndex(weightIndex, node.value));\n      nodeMax = Math.max(nodeMax, weightAtIndex(weightIndex, node.value));\n    }\n  }\n\n  return [nodeMin, nodeMax];\n}\n","import { AnalyzeNetwork, IEdge, INetworkData, INode } from \"../types\";\nimport { cloneEdge } from \"./clone-edge\";\nimport { cloneNode } from \"./clone-node\";\n\n/**\n * This deep clones a network object (except for meta data)\n */\nexport function cloneNetwork<TNodeMeta, TEdgeMeta>(\n  network: AnalyzeNetwork<TNodeMeta, TEdgeMeta>\n): INetworkData<TNodeMeta, TEdgeMeta> {\n  const atobMap = new Map();\n  const edgeMap = new Map();\n  const nodeMap = new Map();\n\n  // Clone all nodes\n  const nodes: INode<TNodeMeta, TEdgeMeta>[] = new Array(network.nodes.length);\n  for (let i = 0, iMax = network.nodes.length; i < iMax; ++i) {\n    const node = cloneNode(network.nodes[i]);\n    nodeMap.set(node.id, node);\n    nodes[i] = node;\n  }\n\n  // Clone all edges\n  const edges: IEdge<TNodeMeta, TEdgeMeta>[] = new Array(network.edges.length);\n  for (let i = 0, iMax = network.edges.length; i < iMax; ++i) {\n    const edge = cloneEdge(network.edges[i]);\n    edgeMap.set(edge.id, edge);\n    edges[i] = edge;\n  }\n\n  // Shift all edge references to new Edge Object references\n  for (let i = 0, iMax = nodes.length; i < iMax; ++i) {\n    const node = nodes[i];\n    node.in = node.in.map((edge) => edgeMap.get(edge.id)).filter(Boolean);\n    node.out = node.out.map((edge) => edgeMap.get(edge.id)).filter(Boolean);\n  }\n\n  // Shift all edge node references to new Node Object references\n  for (let i = 0, iMax = edges.length; i < iMax; ++i) {\n    const edge = edges[i];\n    edge.a = nodeMap.get(edge.a.id);\n    edge.b = nodeMap.get(edge.b.id);\n  }\n\n  // Update the a to b mapping\n  network.atobMap.forEach((map, nodeA) => {\n    const mapB = new Map();\n    atobMap.set(nodeMap.get(nodeA.id), mapB);\n    map.forEach((edge, nodeB) =>\n      mapB.set(nodeMap.get(nodeB.id), edgeMap.get(edge.id))\n    );\n  });\n\n  return {\n    atobMap,\n    edgeMap,\n    edges,\n    nodeMap,\n    nodes,\n  };\n}\n","import { DataProvider, values } from \"simple-data-provider\";\nimport {\n  Accessor,\n  Identifier,\n  IEdge,\n  IMakeNetworkError,\n  IMakeNetworkResult,\n  INetworkData,\n  INode,\n  isDefined,\n  isEdgeWeights,\n  isIdentifier,\n  isWeights,\n  MakeNetworkErrorType,\n  Weights,\n} from \"../types\";\nimport { addToMapOfMaps, makeList, removeFromMapOfMaps } from \"../util\";\nimport { access } from \"../util/access\";\nimport { makeError } from \"../util/make-error\";\n\nexport type NodePair<TNode> = { a: TNode; b: TNode };\nexport type EdgeFlow<TEdge> = { ab: TEdge[]; ba: TEdge[] };\nexport type EdgeValues = { ab?: Weights; ba?: Weights } | undefined;\n\nfunction isEdgeFlow<TEdge>(val: any): val is EdgeFlow<TEdge> {\n  return val && val.a && val.b && Array.isArray(val.a) && Array.isArray(val.b);\n}\n\nexport function isNodePair<TNode>(val: any): val is NodePair<TNode> {\n  return val && val.a && val.b;\n}\n\nexport interface IConvertNetworkOptions<\n  TNodeSource,\n  TEdgeSource,\n  TNodeMeta,\n  TEdgeMeta,\n  TNodeInfo,\n  TEdgeInfo\n> {\n  /**\n   * This is the data that will be traversed for conversion. Each node is\n   * expected to connect to other nodes by means of an edge or connect directly\n   * to a node of a same type.\n   */\n  data: DataProvider<TNodeSource>;\n\n  /**\n   * This specifies how to find the children of the provided object. The\n   * children should be another TNode type. If the node does not reference\n   * children directly via reference but via a linking object (like an edge)\n   * then make sure you specify the \"edge\" accessor. Edges will also be passed\n   * into this object to find the nodes of the edge\n   */\n  nodes: Accessor<TNodeSource, TNodeSource[], TNodeInfo>;\n\n  /**\n   * Retrieves the NodeSource associated with the A connection of an EdgeSource\n   */\n  nodeA: Accessor<TEdgeSource, TNodeSource, never>;\n\n  /**\n   * Retrieves the NodeSource associated with the B connection of an EdgeSource\n   */\n  nodeB: Accessor<TEdgeSource, TNodeSource, never>;\n\n  /**\n   * Accessor to provide the identifier for the node currently in use.\n   *\n   * You can return multiple identifiers for a single node of data to split the\n   * node being processed into multiple nodes for the Network Data being\n   * generated.\n   */\n  nodeId: Accessor<TNodeSource, Identifier | Identifier[], never>;\n\n  /**\n   * This retrieves info from a node source that is related to the provided\n   * identifier. All Accessors related to nodes will be passed this information\n   * so they can make more informed decisions on their data access.\n   */\n  nodeInfo?(id: Identifier, idIndex: number, data: TNodeSource): TNodeInfo;\n\n  /**\n   * This accessor retrieves any meta information from a node you wish to store\n   * with the node.\n   */\n  nodeMeta?: Accessor<TNodeSource, TNodeMeta, TNodeInfo>;\n\n  /**\n   * This accessor retrieves the values associated with the node.\n   */\n  nodeValue: Accessor<TNodeSource, Weights, TNodeInfo>;\n\n  /**\n   * This specifies how to find edge type objects that are linked to this node.\n   * Simply return all edge style objects the node may have. The edge will then\n   * be processed for it's nodes in the nodes accessor.\n   *\n   * If this passes in a single node, then you should return all known edges\n   * that represent outgoing (a to b) and incoming edges (b to a). If each node\n   * only knows outgoing or only incoming edges it is valid to leave ab or ba\n   * blank.\n   *\n   * If this passes in a node pair {a, b} the pair indicates the directionaly it\n   * expects with one node keyed as 'a' and one as 'b' for you.\n   */\n  edges: Accessor<\n    TNodeSource | NodePair<TNodeSource>,\n    { ab: TEdgeSource[]; ba: TEdgeSource[] },\n    TEdgeInfo\n  >;\n\n  /**\n   * Accessor to provide the identifier for the edge. Edges arise from either\n   * a specific edge object, or the edge arises from two nodes linked directly\n   * together.\n   */\n  edgeId?: Accessor<TEdgeSource, Identifier | Identifier[], never>;\n\n  /**\n   * This retrieves info from an edge source that is related to the provided\n   * identifier. All Accessors related to edges will be passed this information\n   * so they can make more informed decisions on their data access.\n   */\n  edgeInfo?(id: Identifier, idIndex: number, data: TEdgeSource): TEdgeInfo;\n\n  /**\n   * Accessor to provide the node the edge emits from. Edges flow from A -> B\n   */\n  edgeA: Accessor<TEdgeSource, Identifier, TEdgeInfo>;\n\n  /**\n   * Accessor to provide the node the edge emits from. Edges flow from A -> B\n   */\n  edgeB: Accessor<TEdgeSource, Identifier, TEdgeInfo>;\n\n  /**\n   * This retrieves any meta information from a node you wish to store with the\n   * edge.\n   */\n  edgeMeta?: Accessor<TEdgeSource, TEdgeMeta, TEdgeInfo>;\n\n  /**\n   * This accessor produces the values an edge will represent from a to b and\n   * b to a.\n   */\n  edgeValues?: Accessor<TEdgeSource, EdgeValues, TEdgeInfo>;\n\n  /**\n   * Supply this with a list of errors you wish to ignore. For instance, in some\n   * cases, it may be necessary to have node's with duplicate identifiers.\n   */\n  suppressErrors?: MakeNetworkErrorType[];\n}\n\n/**\n * The goal of this method is to take a pre-existing network style of\n * information (Objects with references to other objects to form a network))\n * and convert it into the common format of INetworkData\n */\nexport async function convertNetwork<\n  TNodeSource,\n  TEdgeSource,\n  TNodeMeta,\n  TEdgeMeta,\n  TNodeInfo,\n  TEdgeInfo\n>(\n  options: IConvertNetworkOptions<\n    TNodeSource,\n    TEdgeSource,\n    TNodeMeta,\n    TEdgeMeta,\n    TNodeInfo,\n    TEdgeInfo\n  >\n): Promise<IMakeNetworkResult<TNodeSource, TEdgeSource, TNodeMeta, TEdgeMeta>> {\n  const {\n    data,\n    nodes: getNodes,\n    nodeA: getNodeA,\n    nodeB: getNodeB,\n    nodeId: getNodeId,\n    nodeInfo: getNodeInfo,\n    nodeValue: getNodeValue,\n    nodeMeta: getNodeMeta,\n\n    edges: getEdges,\n    edgeId: getEdgeId,\n    edgeA: getEdgeA,\n    edgeB: getEdgeB,\n    edgeInfo: getEdgeInfo,\n    edgeMeta: getEdgeMeta,\n    edgeValues: getEdgeValues,\n\n    suppressErrors = [],\n  } = options;\n  // As this data is created, there may be errors that are produced\n  const errors: IMakeNetworkError<TNodeSource, TEdgeSource>[] = [];\n  // Make a set from our list of errors to suppress so it can be utilized by our\n  // makeError method.\n  const suppress = new Set(suppressErrors || []);\n\n  // List of nodes output into the network\n  const nodeList: INode<TNodeMeta, TEdgeMeta>[] = [];\n  // List of edges output into the network\n  const edgeList: IEdge<TNodeMeta, TEdgeMeta>[] = [];\n  // Create a lookup to retrieve a node by it's identifier\n  const nodeMap = new Map<Identifier, INode<TNodeMeta, TEdgeMeta>>();\n  // Create a lookup to retrieve an edge by it's identifier\n  const edgeMap = new Map<Identifier, IEdge<TNodeMeta, TEdgeMeta>>();\n  // Create the lookup that stores our atob edge lookup\n  const atobMap: INetworkData<TNodeMeta, TEdgeMeta>[\"atobMap\"] = new Map();\n\n  // This contains all of the newly generated nodes that will be applied to the\n  // network data object\n  const newNodes = new Set<INode<TNodeMeta, TEdgeMeta>>();\n  // This contains all of the newly generated edges that will be applied to the\n  // network data object\n  const newEdges = new Set<IEdge<TNodeMeta, TEdgeMeta>>();\n\n  // As we loop through all of the nodes, we will have to gather all of the edge\n  // flows found from those nodes first. AFTER ALL nodes have been processed we\n  // then will be able to process the edge flows to convert them to Edge objects\n  let allEdgeFlows: EdgeFlow<TEdgeSource>[] = [];\n\n  // This is the network we will output as a result of the conversion\n  const network: INetworkData<TNodeMeta, TEdgeMeta> = {\n    nodes: nodeList,\n    edges: edgeList,\n    nodeMap,\n    edgeMap,\n    atobMap,\n  };\n\n  // In the event the edgeId accessor is not provided, we will generate an ID\n  // the edges added in.\n  let autoEdgeId = -1;\n\n  // Loop through the source data objects and convert them into our network\n  // information\n  for await (const node of values(data)) {\n    // Make our processing queue to process the elements as they are found\n    // without recursion.\n    const toProcess = [node];\n\n    while (toProcess.length) {\n      const processNode = toProcess.pop();\n      if (!processNode) continue;\n\n      // Get the identifiers of the node we are processing\n      const nodeIds = makeList(\n        access(processNode, getNodeId, isIdentifier) || []\n      );\n\n      // Loop through each identifier the single node produced to produce the\n      // nodes that will be output for our network\n      for (let i = 0, iMax = nodeIds.length; i < iMax; ++i) {\n        const nodeId = nodeIds[i];\n\n        // Validate the node identifier. We do NOT allow empty node ids\n        if (nodeId === void 0 || nodeId === null) {\n          makeError(suppress, errors, {\n            error: MakeNetworkErrorType.BAD_ID,\n            source: processNode,\n            message: `An node was generated that has an invalid ID: \"${nodeId}\"`,\n          });\n        }\n\n        // See if we have a created node for the given id\n        const previousNode = nodeMap.get(nodeId);\n\n        // If a node already exists, then this is a duplicate node and will\n        // produce an error for our output\n        if (previousNode) {\n          makeError(suppress, errors, {\n            error: MakeNetworkErrorType.DUPLICATE_NODE_ID,\n            source: [previousNode, processNode],\n            message:\n              \"Two nodes have the same Identifier. This overrides the previous node discovered\",\n          });\n\n          newNodes.delete(previousNode);\n        }\n\n        // Get the node information, if any, for this particular identifier\n        const nodeInfo = getNodeInfo?.(nodeId, i, processNode);\n\n        // Create the new node we have derived\n        const newNode: INode<TNodeMeta, TEdgeMeta> = {\n          id: nodeId,\n          in: [],\n          out: [],\n          value: access(processNode, getNodeValue, isWeights, nodeInfo) || 0,\n          meta:\n            access(\n              processNode,\n              getNodeMeta,\n              (val: any): val is TNodeMeta => val\n            ) || void 0,\n        };\n\n        // Set our node as the node for this provided identifier\n        newNodes.add(newNode);\n        nodeMap.set(nodeId, newNode);\n\n        // We get the children from the node. These will be the next nodes to\n        // be processed in the queue, but more importantly, nodes retrieved from\n        // a node is cause to create an actual edge between the two.\n        const nodeToNodes =\n          access(processNode, getNodes, (val): val is TNodeSource[] =>\n            Array.isArray(val)\n          ) || [];\n\n        // We add the new nodes discovered to our processing list\n        for (let k = 0, kMax = nodeToNodes.length; k < kMax; ++k) {\n          const node = nodeToNodes[k];\n          toProcess.push(node);\n        }\n\n        // Get the edge sources from our node to node relationships\n        const nodeToNodeEdgeFlows = nodeToNodes.map((childNode) =>\n          access<NodePair<TNodeSource>, EdgeFlow<TEdgeSource>, never>(\n            { a: processNode, b: childNode },\n            getEdges,\n            isEdgeFlow\n          )\n        );\n\n        // Get the edges that may be referenced from the node itself\n        const edgeFlow = access<TNodeSource, EdgeFlow<TEdgeSource>, never>(\n          processNode,\n          getEdges,\n          isEdgeFlow\n        );\n\n        // Gather all of our edge flows we found into a single list for\n        // processing and make sure each element is valid\n        const edgeFlows = nodeToNodeEdgeFlows\n          .concat(edgeFlow)\n          .filter(isDefined);\n        allEdgeFlows = allEdgeFlows.concat(edgeFlows);\n\n        // If we have actual edge style objects connecting elements, then we\n        // should process those edges to see if they are the connection to the\n        // next set of nodes.\n        getNodesForEdgeFlows<TNodeSource, TEdgeSource>(\n          edgeFlow,\n          getNodeA,\n          getNodeB,\n          toProcess,\n          errors,\n          suppress\n        );\n      }\n    }\n  }\n\n  // Each edge flow must be processed now to convert them to Edge Objects. We\n  // now have all of the listed nodes so we can properly reference everything by\n  // identifier at this point, thus making valid edges\n  for (let i = 0, iMax = allEdgeFlows.length; i < iMax; ++i) {\n    const flow = allEdgeFlows[i];\n\n    // Loop through the ab connections identified and create the Network\n    // data style Edge object\n    for (let k = 0, kMax = flow.ab.length; k < kMax; ++k) {\n      const processEdge = flow.ab[k];\n      const edgeIds = getEdgeId\n        ? makeList(access(processEdge, getEdgeId, isIdentifier) || [])\n        : [++autoEdgeId];\n\n      // Just like nodes, each Edge Source can theoretically list multiple edges\n      // albeit in rare complex cases.\n      for (let j = 0, jMax = edgeIds.length; j < jMax; ++j) {\n        const edgeId = edgeIds[j];\n\n        if (edgeId === void 0 || edgeId === null) {\n          makeError(suppress, errors, {\n            error: MakeNetworkErrorType.BAD_ID,\n            source: processEdge,\n            message: \"An edge was generated that has an invalid ID\",\n          });\n\n          continue;\n        }\n\n        // Check for existing edges we have already parsed for this id to see if\n        // we are triggering an override of an existing edge.\n        const previousEdge = edgeMap.get(edgeId);\n\n        if (previousEdge) {\n          makeError(suppress, errors, {\n            error: MakeNetworkErrorType.DUPLICATE_EDGE_ID,\n            source: [previousEdge, processEdge],\n            message:\n              \"Two edges have the same Identifier. This overrides the previous edge discovered\",\n          });\n\n          newEdges.delete(previousEdge);\n          removeFromMapOfMaps(atobMap, previousEdge.a, previousEdge.b);\n        }\n\n        // Get the info associated with the edge identifier so we can pass\n        // it onto the next metrics\n        const edgeInfo = getEdgeInfo?.(edgeId, j, processEdge);\n        const edgeA = nodeMap.get(\n          access(processEdge, getEdgeA, isIdentifier, edgeInfo) || \"\"\n        );\n        const edgeB = nodeMap.get(\n          access(processEdge, getEdgeB, isIdentifier, edgeInfo) || \"\"\n        );\n\n        if (!edgeA || !edgeB) {\n          makeError(suppress, errors, {\n            error: MakeNetworkErrorType.NODE_NOT_FOUND,\n            source: processEdge,\n            message:\n              \"An edge targetted two nodes for it's a and b, but both were not found\",\n          });\n\n          continue;\n        }\n\n        const edgeValues = access(\n          processEdge,\n          getEdgeValues,\n          isEdgeWeights,\n          edgeInfo\n        );\n\n        const newEdge: IEdge<TNodeMeta, TEdgeMeta> = {\n          id: edgeId,\n          a: edgeA,\n          b: edgeB,\n          atob: edgeValues?.ab || 0,\n          btoa: edgeValues?.ba || 0,\n          meta: access(processEdge, getEdgeMeta, isDefined, edgeInfo),\n        };\n\n        // Register the edge into the network info\n        newEdges.add(newEdge);\n        edgeMap.set(edgeId, newEdge);\n        addToMapOfMaps(atobMap, newEdge.a, newEdge.b, newEdge);\n      }\n    }\n  }\n\n  // Apply all of our final edges and nodes we generated to the network data\n  network.nodes = Array.from(newNodes.values());\n  network.edges = Array.from(newEdges.values());\n\n  // After all edges have been established, register each edge with it's\n  // respective nodes\n  for (let i = 0, iMax = network.edges.length; i < iMax; ++i) {\n    const edge = network.edges[i];\n    edge.a.out.push(edge);\n    edge.b.in.push(edge);\n  }\n\n  // Output our new network data object with all errors that happened attached\n  // to it\n  return Object.assign(network, { errors });\n}\n\n/**\n * When we process the node sources and edge sources, we derive edge flows or\n * Edge Sources that indicated connection from a to b and b to a. We must\n * process those flows to look for nodes on each end of them for processing.\n */\nfunction getNodesForEdgeFlows<TNodeSource, TEdgeSource>(\n  edgeFlow: EdgeFlow<TEdgeSource> | null,\n  getNodeA: Accessor<TEdgeSource, TNodeSource, never>,\n  getNodeB: Accessor<TEdgeSource, TNodeSource, never>,\n  toProcess: TNodeSource[],\n  errors: IMakeNetworkError<TNodeSource, TEdgeSource>[],\n  suppress: Set<MakeNetworkErrorType>\n) {\n  if (edgeFlow) {\n    // Loop through the ab edges and retrieve the B node of the edge\n    for (let k = 0, kMax = edgeFlow.ab.length; k < kMax; ++k) {\n      const processEdge = edgeFlow.ab[k];\n      // This processes the edge source information to identify the\n      // connected nodes associated with the edge\n      const edgeToNodeB = access<TEdgeSource, TNodeSource, never>(\n        processEdge,\n        getNodeB,\n        isDefined\n      );\n\n      // Queue up the found node for processing\n      if (edgeToNodeB) {\n        toProcess.push(edgeToNodeB);\n      } else {\n        makeError(suppress, errors, {\n          error: MakeNetworkErrorType.NODE_NOT_FOUND,\n          source: processEdge,\n          message:\n            \"Could not determine the NodeSource for the provided edge information\",\n        });\n      }\n    }\n\n    // Loop through the ba edges and retrieve the A node of the edge\n    for (let k = 0, kMax = edgeFlow.ab.length; k < kMax; ++k) {\n      const processEdge = edgeFlow.ab[k];\n      // This processes the edge source information to identify the\n      // connected nodes associated with the edge\n      const edgeToNodeA = access<TEdgeSource, TNodeSource, never>(\n        processEdge,\n        getNodeA,\n        isDefined\n      );\n\n      // Queue up the found node for processing\n      if (edgeToNodeA) {\n        toProcess.push(edgeToNodeA);\n      } else {\n        makeError(suppress, errors, {\n          error: MakeNetworkErrorType.NODE_NOT_FOUND,\n          source: processEdge,\n          message:\n            \"Could not determine the NodeSource for the provided edge information\",\n        });\n      }\n    }\n  }\n}\n","import { getEdge } from \"../calculate\";\nimport {\n  AnalyzeNetwork,\n  IEdge,\n  INetworkData,\n  INode,\n  ProcessNetwork,\n} from \"../types\";\nimport { addToMapOfMaps } from \"../util\";\nimport { cloneEdge } from \"./clone-edge\";\nimport { cloneNode } from \"./clone-node\";\nimport { emptyNetwork } from \"./empty-network\";\nimport { makeNetwork, MakeNetworkAggregateValueMode } from \"./make-network\";\n\nexport enum IntersectMode {\n  USE_A,\n  USE_B,\n  INTERSECT,\n}\n\ninterface IIntersect<TNodeMeta, TEdgeMeta> {\n  type: IntersectMode;\n  nodeIntersection?(\n    nodeA: INode<TNodeMeta, TEdgeMeta>,\n    nodeB: INode<TNodeMeta, TEdgeMeta>\n  ): INode<TNodeMeta, TEdgeMeta>;\n  edgeIntersection?(\n    edgeA: IEdge<TNodeMeta, TEdgeMeta>,\n    edgeB: IEdge<TNodeMeta, TEdgeMeta>\n  ): IEdge<TNodeMeta, TEdgeMeta>;\n}\n\ninterface IIntersectUse<TNodeMeta, TEdgeMeta>\n  extends IIntersect<TNodeMeta, TEdgeMeta> {\n  type: IntersectMode.USE_A | IntersectMode.USE_B;\n}\n\ninterface IIntersectMerge<TNodeMeta, TEdgeMeta>\n  extends IIntersect<TNodeMeta, TEdgeMeta> {\n  type: IntersectMode.INTERSECT;\n  nodeIntersection(\n    nodeA: INode<TNodeMeta, TEdgeMeta>,\n    nodeB: INode<TNodeMeta, TEdgeMeta>\n  ): INode<TNodeMeta, TEdgeMeta>;\n  edgeIntersection(\n    edgeA: IEdge<TNodeMeta, TEdgeMeta>,\n    edgeB: IEdge<TNodeMeta, TEdgeMeta>\n  ): IEdge<TNodeMeta, TEdgeMeta>;\n}\n\n/**\n * This method will calculate the intersection of elements between two networks.\n * This uses identifiers and not object references to make the associations.\n *\n * Intersection means only elements that appear in Set A AND Set B. Essentially\n * the opposite result of difference.\n *\n * A: {1, 3, 4, 9} B: {2, 4, 5, 9}\n *\n * result: {4, 9}\n *\n * @param a First network to compare against\n * @param b Second network to compare against\n * @param strategy This sets which node or edge to pick when forming the\n *                 intersected networok. This allows some intervention in which\n *                 objects to pick, as well as provide a way to create\n *                 completely new objects for selection.\n */\nexport async function intersection<TNodeMeta, TEdgeMeta>(\n  a: AnalyzeNetwork<TNodeMeta, TEdgeMeta>,\n  b: AnalyzeNetwork<TNodeMeta, TEdgeMeta>,\n  strategy:\n    | IIntersectUse<TNodeMeta, TEdgeMeta>\n    | IIntersectMerge<TNodeMeta, TEdgeMeta>\n): Promise<ProcessNetwork<TNodeMeta, TEdgeMeta> | null> {\n  // This will be the network object we aggregate our newly formed network data\n  // into.\n  const network: AnalyzeNetwork<TNodeMeta, TEdgeMeta> = emptyNetwork();\n\n  let pickNode: (\n    nodeA: INode<TNodeMeta, TEdgeMeta>,\n    nodeB: INode<TNodeMeta, TEdgeMeta>\n  ) => INode<TNodeMeta, TEdgeMeta>;\n  let pickEdge: (\n    edgeA: IEdge<TNodeMeta, TEdgeMeta>,\n    edgeB: IEdge<TNodeMeta, TEdgeMeta>\n  ) => IEdge<TNodeMeta, TEdgeMeta>;\n\n  // Determine how we pick an edge between two networks\n  if (strategy.type === IntersectMode.USE_B) {\n    pickNode = (\n      _: INode<TNodeMeta, TEdgeMeta>,\n      nodeB: INode<TNodeMeta, TEdgeMeta>\n    ) => nodeB;\n    pickEdge = (\n      _: IEdge<TNodeMeta, TEdgeMeta>,\n      edgeB: IEdge<TNodeMeta, TEdgeMeta>\n    ) => edgeB;\n  } else if (strategy.type === IntersectMode.INTERSECT) {\n    pickNode = strategy.nodeIntersection;\n    pickEdge = strategy.edgeIntersection;\n  } else {\n    pickNode = (\n      nodeA: INode<TNodeMeta, TEdgeMeta>,\n      _: INode<TNodeMeta, TEdgeMeta>\n    ) => nodeA;\n    pickEdge = (\n      edgeA: IEdge<TNodeMeta, TEdgeMeta>,\n      _: IEdge<TNodeMeta, TEdgeMeta>\n    ) => edgeA;\n  }\n\n  // We must loop through only one of the networks and determine if the network\n  // has elements that exists in the other network\n  for (let i = 0, iMax = a.nodes.length; i < iMax; ++i) {\n    const nodeA = a.nodes[i];\n    const nodeB = b.nodeMap.get(nodeA.id);\n\n    if (nodeB) {\n      const combined = cloneNode(pickNode(nodeA, nodeB));\n      // Add the combined node into our new network. As a precaution we will\n      // make it a new Object reference so we reduce confusion by not allowing\n      // modifications of this object to affect the two input networks.\n      combined.in = [];\n      combined.out = [];\n      network.nodes.push(combined);\n      network.nodeMap.set(combined.id, combined);\n    }\n  }\n\n  // We now loop through all of the edges and weigh each edge's a and b\n  // identifiers against the nodes we have found to be shared. This will allow\n  // us to identify which edge's would be valid in the intersection. We then\n  // take that edge and weigh it against the other network's a to b map to see\n  // if they share the same edge.\n  for (let i = 0, iMax = a.edges.length; i < iMax; ++i) {\n    const edge = a.edges[i];\n    const nodeA = network.nodeMap.get(edge.a.id);\n    const nodeB = network.nodeMap.get(edge.b.id);\n\n    // See if we have the shared nodes\n    if (nodeA && nodeB) {\n      // Make sure the other network has the same connection\n      const checkA = b.nodeMap.get(edge.a.id);\n      const checkB = b.nodeMap.get(edge.b.id);\n      if (!checkA || !checkB) continue;\n      const checkEdge = getEdge(checkA, checkB, b);\n      if (!checkEdge) continue;\n      // At this point, we have determined both networks have the same node to\n      // node connection. So we should add the edge to the new network\n      const combined = cloneEdge(pickEdge(edge, checkEdge));\n      combined.a = nodeA;\n      combined.b = nodeB;\n      network.edges.push(combined);\n      network.edgeMap.set(combined.id, combined);\n      nodeA.out.push(combined);\n      nodeB.in.push(combined);\n      addToMapOfMaps(network.atobMap, combined.a, combined.b, combined);\n    }\n  }\n\n  return network;\n}\n\n/**\n * This method will calculate the union of elements between two networks.\n *\n * Union means elements that appear in both sets, but no duplicates. Essentially\n * the opposite result of intersection.\n *\n * A: {1, 3, 4, 9} B: {2, 4, 5, 9}\n *\n * result: {1, 2, 3, 4, 5, 9}\n *\n * @param a First network to compare against\n * @param b Second network to compare against\n * @param nodeIntersection This is called when two nodes are valid\n *                         intersections. You have the opportunity to merge the\n *                         nodes how you see fit and return the merged node.\n * @param edgeIntersection This is called when two edges are valid\n *                         intersections. You have the opportunity to merge the\n *                         edges how you see fit and return the merged edge.\n */\nexport async function union<TNodeMeta, TEdgeMeta>(\n  a: AnalyzeNetwork<TNodeMeta, TEdgeMeta>,\n  b: AnalyzeNetwork<TNodeMeta, TEdgeMeta>,\n  strategy: IIntersectUse<TNodeMeta, TEdgeMeta>\n): Promise<ProcessNetwork<TNodeMeta, TEdgeMeta> | null> {\n  let allNodes = a.nodes.concat(b.nodes);\n  let allEdges = a.edges.concat(b.edges);\n  let aggregateMode: MakeNetworkAggregateValueMode;\n\n  if (strategy.type === IntersectMode.USE_B) {\n    // We override as we process, so we make b values remain at the end making\n    // them the remaining values\n    aggregateMode = MakeNetworkAggregateValueMode.OVERRIDE;\n    allNodes = a.nodes.concat(b.nodes);\n    allEdges = a.edges.concat(b.edges);\n  } else {\n    // We override as we process, so we make a values remain at the end making\n    // them the remaining values\n    aggregateMode = MakeNetworkAggregateValueMode.OVERRIDE;\n    allNodes = b.nodes.concat(a.nodes);\n    allEdges = b.edges.concat(a.edges);\n  }\n\n  // Generate a new network by analyzing all of the original network data to\n  // make a new network where we use the nodes and edge data of the previous\n  // networks as the row data needed to make the new network.\n  const network = await makeNetwork({\n    // We aggregate results because we will have multiple overlapping nodes\n    // potentially. The aggregation style will depend on the strategy for making\n    // the union.\n    aggregateResults: true,\n    aggregateValueMode: aggregateMode,\n\n    // Set the data to process for the network\n    nodeData: allNodes,\n    edgeData: allEdges,\n\n    // Identify the relevant information for nodes\n    nodeId: (node) => node.id,\n    nodeMeta: (node) => node.meta as TNodeMeta,\n    nodeValues: (node) => node.value,\n\n    // Identify the relevant information for edges\n    edgeId: (edge) => edge.id,\n    edgeA: (edge) => edge.a.id,\n    edgeB: (edge) => edge.b.id,\n    edgeMeta: (edge) => edge.meta as TEdgeMeta,\n    edgeValues: (edge) => ({ ab: edge.atob, ba: edge.btoa }),\n  });\n\n  return network;\n}\n\n/**\n * This method will calculate the difference of elements between two networks.\n *\n * Difference means elements that do NOT appear in both sets\n *\n * A: {1, 3, 4, 9} B: {2, 4, 5, 9}\n *\n * result: {1, 2, 3, 5}\n *\n * @param a First network to compare against\n * @param b Second network to compare against\n * @param nodeIntersection This is called when two nodes are valid\n *                         intersections. You have the opportunity to merge the\n *                         nodes how you see fit and return the merged node.\n * @param edgeIntersection This is called when two edges are valid\n *                         intersections. You have the opportunity to merge the\n *                         edges how you see fit and return the merged edge.\n */\nexport async function difference<TNodeMeta, TEdgeMeta>(\n  a: AnalyzeNetwork<TNodeMeta, TEdgeMeta>,\n  b: AnalyzeNetwork<TNodeMeta, TEdgeMeta>\n) {\n  // This will be the network object we aggregate our newly formed network data\n  // into.\n  const network: INetworkData<TNodeMeta, TEdgeMeta> = emptyNetwork();\n\n  // We must loop through the first network and determine if the network\n  // has elements that does not exist in the other network\n  for (let i = 0, iMax = a.nodes.length; i < iMax; ++i) {\n    const nodeA = a.nodes[i];\n    const nodeB = b.nodeMap.get(nodeA.id);\n\n    // If this does not exist in the other network, then we keep the node\n    if (!nodeB) {\n      network.nodes.push(nodeA);\n      network.nodeMap.set(nodeA.id, nodeA);\n    }\n  }\n\n  // Now we loop through the other network and determine if the network\n  // has elements that does not exist in the first network\n  for (let i = 0, iMax = b.nodes.length; i < iMax; ++i) {\n    const nodeA = b.nodes[i];\n    const nodeB = a.nodeMap.get(nodeA.id);\n\n    // If this does not exist in the other network, then we keep the node\n    if (!nodeB) {\n      network.nodes.push(nodeA);\n      network.nodeMap.set(nodeA.id, nodeA);\n    }\n  }\n\n  // We now loop through all of the edges and weigh each edge's a and b\n  // identifiers against the nodes we have found to be shared. This will allow\n  // us to identify which edge's would be valid in the intersection. We then\n  // take that edge and weigh it against the other network's a to b map to see\n  // if they share the same edge.\n  for (let i = 0, iMax = a.edges.length; i < iMax; ++i) {\n    const edge = a.edges[i];\n    const nodeA = network.nodeMap.get(edge.a.id);\n    const nodeB = network.nodeMap.get(edge.b.id);\n\n    // See if the nodes for the edges were kept when finding the different nodes\n    // If both nodes are in our new network, then we keep the edge as well.\n    if (nodeA && nodeB) {\n      network.edges.push(edge);\n      network.edgeMap.set(edge.id, edge);\n      addToMapOfMaps(network.atobMap, edge.a, edge.b, edge);\n    }\n  }\n\n  return network;\n}\n\nexport const NetworkSet = {\n  union,\n  intersection,\n  difference,\n};\n","import { ProcessNetwork } from \"../types\";\nimport { removeEdge } from \"./remove-edge\";\n\n/**\n * This method removes any edge from the network that starts and ends at the\n * same node.\n */\nexport function removeCircularEdges<TNodeMeta, TEdgeMeta>(\n  network: ProcessNetwork<TNodeMeta, TEdgeMeta>\n) {\n  const edges = network.edges.slice(0);\n\n  for (let i = 0, iMax = edges.length; i < iMax; ++i) {\n    const edge = edges[i];\n\n    if (edge.a === edge.b) {\n      removeEdge(network, edge);\n    }\n  }\n\n  return network;\n}\n"],"sourceRoot":""}